<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Scratchapixel https://www.Scratchapixel.com/index.php?redirect               一个非常棒的学习计算机图形学的网站32节课166篇文章C++源代码            该文章就是在阅读学习这个网站时做的笔记">
<meta name="keywords" content="C++,Graphics,Note">
<meta property="og:type" content="article">
<meta property="og:title" content="图形学 笔记">
<meta property="og:url" content="http://yoursite.com/Tech/ScratchapixelNote/index.html">
<meta property="og:site_name" content="Van">
<meta property="og:description" content="Scratchapixel https://www.Scratchapixel.com/index.php?redirect               一个非常棒的学习计算机图形学的网站32节课166篇文章C++源代码            该文章就是在阅读学习这个网站时做的笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/coordinateSystem.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/cross.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/camDir.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/ortho01.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/persp01.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/fov01.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/fov02.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/microfacets_light_rays.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/surface_reaction.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/solid_angle.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/radiant_intensity.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/radiance.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/ndf.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/geometry_shadowing.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/light_casters_spotlight_angles.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/parallax_mapping_scaled_height.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/parallax_mapping_scaled_height2.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/parallax_mapping_incorrect_p.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/deferred_g_buffer.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/bloom_gaussian.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/bloom_gaussian_two_pass.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/RayMarching.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/08_displacement_05.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/TF2npr01.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/TF2npr02.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/thickness.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/directAndTranslucency.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/allTogether.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend01.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend02.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend03.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend04.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend05.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend06.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend07.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend08.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend09.png">
<meta property="og:image" content="http://yoursite.com/images/Notes/Graphics/terrainBlend10.png">
<meta property="og:updated_time" content="2021-03-28T06:10:01.042Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="图形学 笔记">
<meta name="twitter:description" content="Scratchapixel https://www.Scratchapixel.com/index.php?redirect               一个非常棒的学习计算机图形学的网站32节课166篇文章C++源代码            该文章就是在阅读学习这个网站时做的笔记">
<meta name="twitter:image" content="http://yoursite.com/images/Notes/Graphics/coordinateSystem.png">

<link rel="canonical" href="http://yoursite.com/Tech/ScratchapixelNote/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>图形学 笔记 | Van</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d76c976ebf90b8fce3fc58985d94aa40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Van</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/fanziwenm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Tech/ScratchapixelNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="业余蚊子">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Van">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图形学 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-17 18:28:49" itemprop="dateCreated datePublished" datetime="2020-01-17T18:28:49+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 14:10:01" itemprop="dateModified" datetime="2021-03-28T14:10:01+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Scratchapixel"><a href="#Scratchapixel" class="headerlink" title="Scratchapixel"></a>Scratchapixel</h1><blockquote>
<p><a href="https://www.Scratchapixel.com/index.php?redirect" target="_blank" rel="noopener">https://www.Scratchapixel.com/index.php?redirect</a></p>
</blockquote>
<div class="note default">
            <p>一个非常棒的学习计算机图形学的网站</p><ul><li>32节课</li><li>166篇文章</li><li>C++源代码</li></ul>
          </div>
<p>该文章就是在阅读学习这个网站时做的笔记</p>
<a id="more"></a>
<h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><blockquote>
<p>几何体</p>
</blockquote>
<h3 id="点，向量，法线"><a href="#点，向量，法线" class="headerlink" title="点，向量，法线"></a>点，向量，法线</h3><blockquote>
<p>Points, Vectors and Normals</p>
</blockquote>
<p>向量的C++源码:<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 3 most basic ways of initializing a vector</span></span><br><span class="line">    Vector() :x(T(<span class="number">0</span>)), y(T(<span class="number">0</span>)), z(T(<span class="number">0</span>)) {}</span><br><span class="line">    Vector(<span class="keyword">const</span> T& xx) : x(xx), y(xx), z(xx) {}</span><br><span class="line">    Vector(T xx, T yy, T zz) : x(xx), y(yy), z(zz) {}</span><br><span class="line">    T x, y, z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><blockquote>
<p>Coordinate Systems</p>
</blockquote>
<p>在初中的时候，我们就知道，假如要在一张纸上画一堆点，我们都知道画两个轴确认这些点的位置信息，也就是<strong>X</strong>轴和<strong>Y</strong>轴。<br>如果这两个轴是相互垂直的，那就构成了一个<strong>笛卡尔坐标系(Cartesian coordinate system)</strong>。<br>然后我们会有一对数来表示某个点的位置，例如<code>p(1.25, 0,5)</code></p>
<p>而三维空间坐标系是二维空间坐标系的简单拓展。我们只是又添加了一个<strong>Z</strong>轴，它同时垂直于<strong>X</strong>和<strong>Y</strong></p>
<p><strong>左手坐标系(left-hand coordinate system)</strong>和<strong>右手坐标系(right-hand coordinate system)</strong><br>下图是Graphics给出的原图：</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\coordinateSystem.png " class="full-image" alt title style="max-width: none; width: 70%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<div class="note primary">
            <p>要记住，<strong>中指</strong>总是表示<strong>朝右向量(right vector)</strong></p>
          </div>
<p>当检查坐标系的时候，最先用中指指向朝右向量，然后检查另外两个手指是否是与另外两个轴方向相同。这样就可以判断是左后还是右手坐标系。<br>坐标系的不同不是根据<strong>轴(Axes)</strong>的命名定的，所以<code>Y</code>轴朝上和<code>Z</code>轴朝上不一定是不同的坐标系。</p>
<div class="note success">
            <p>唯一能定义一个坐标系的是<strong>朝右向量(right vector)</strong>和<strong>朝上(up)</strong>,<strong>朝前(forward)</strong>相对的方向。而至于怎么标记这些轴并不重要</p>
          </div>
<hr>
<h3 id="点和向量的数学运算"><a href="#点和向量的数学运算" class="headerlink" title="点和向量的数学运算"></a>点和向量的数学运算</h3><blockquote>
<p>Math Operations on Points and Vectors</p>
</blockquote>
<hr>
<h4 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h4><blockquote>
<p>长度</p>
</blockquote>
<p>求向量<strong>长度(length)</strong>也叫<strong>模</strong>：</p>
<script type="math/tex; mode=display">
\left \| V \right \| = \sqrt{V.x^2 + V.y^2 + V.z^2}</script><p><strong>C++</strong>代码：</p>
<ul>
<li>作为一个类里的成员函数</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">T <span class="title">length</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y + z * z);</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>作为一个函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="function">T <span class="title">length</span><span class="params">(<span class="keyword">const</span> Vector<t> &v)</t></span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(v.x * v.x + v.y * v.y + v.z * v.z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize"></a>Normalize</h4><blockquote>
<p>归一化</p>
</blockquote>
<p>向量的<strong>归一化(Normalize)</strong>:</p>
<script type="math/tex; mode=display">
\widehat{V} = \frac{V}{\left \| V \right \|}</script><p><strong>单位向量(unit vector)</strong>，一个长度为<code>1</code>的向量，所以归一化除以自身长度即可。</p>
<p><strong>C++</strong>代码：</p>
<ul>
<li>作为一个类成员函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Vector&ltT&gt& <span class="title">normalize</span><span class="params">()</span> </span>{</span><br><span class="line">        T len = length();</span><br><span class="line">        <span class="keyword">if</span> (len > <span class="number">0</span>) {</span><br><span class="line">            T invLen = <span class="number">1</span> / len;</span><br><span class="line">            x *= invLen, y *= invLen, z *= invLen;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>作为一个函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(Vector&ltT&gt &v )</span></span>{</span><br><span class="line">    T len = length(v);</span><br><span class="line">    <span class="keyword">if</span> (len > <span class="number">0</span>) {</span><br><span class="line">        T invLen = <span class="number">1</span> / len;</span><br><span class="line">        v.x *= invLen;</span><br><span class="line">        v.y *= invLen;</span><br><span class="line">        v.z *= invLen;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="Dot-Product"><a href="#Dot-Product" class="headerlink" title="Dot Product"></a>Dot Product</h4><blockquote>
<p>点乘</p>
</blockquote>
<script type="math/tex; mode=display">
A\cdot B = A.x* B.x + A.y * B.y + A.z * B.z</script><p>$A$向量<strong>点乘(Dot)</strong>$B$向量，写做 $A\cdot B$，将两个向量进行点乘是一个非常常见的操作，因为它的结果和两向量<strong>夹角 $\theta$ 的余弦</strong>有关：</p>
<script type="math/tex; mode=display">
A\cdot B = \left \| A \right \|\left \| B \right \|cos(\theta )</script><p>所以，如果两个向量AB都是<strong>单位向量</strong>那么点乘的结果就是这两个向量夹角 $\theta$ 的<strong>余弦值</strong>。</p>
<p>通过点乘求夹角 $\theta$ ：</p>
<script type="math/tex; mode=display">
\theta = cos^{-1}(\frac{A\cdot B}{\left \| A \right \|\left \| B \right \|})</script><div class="note default">
            <p>在数学中，$cos^-1$是余弦的反置<strong>反余弦(arc cosine)</strong>,在计算机编程语言中一般用<code>acos()</code>函数表示</p>
          </div>
<div class="note info">
            <p>注意，点乘的公式和之前讲到的求向量长度的公式很像，如果两个<strong>相同向量</strong>点乘，这就是一个没有<strong>平方根</strong>长度公式。所以还有个公式：</p><script type="math/tex; mode=display">\left \| V \right \|^{2} = V\cdot V</script>
          </div>
<div class="note success">
            <p>点乘在3D图形中是非常重要的操作。可以用在很多地方，最常用的就是测试两个向量是否垂直，如果两个向量垂直，那他们的点乘的值为<code>0</code></p>
          </div>
<p><strong>C++</strong>代码：</p>
<ul>
<li>作为一个类成员函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vector&ltT&gt  &v)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x * v.x + y * v.y + z * v.z;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>作为一个函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="function">T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vector&ltT&gt& v1, <span class="keyword">const</span> Vector&ltT&gt& v2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="Cross-Product"><a href="#Cross-Product" class="headerlink" title="Cross Product"></a>Cross Product</h4><blockquote>
<p>叉乘</p>
</blockquote>
<p><strong>叉乘(Cross Product)</strong>也是对两个向量进行操作。和点乘不同的是返回值是一个<strong>向量</strong>例如向量$A$和向量$B$叉乘出向量$C$:</p>
<script type="math/tex; mode=display">
C = A \times B</script><script type="math/tex; mode=display">
\begin{bmatrix}
C.x\\ 
C.y\\ 
C.z
\end{bmatrix} = \begin{bmatrix}
A.y*B.z - A.z*B.y\\ 
A.z*B.x - A.x*B.z\\ 
A.x*B.y - A.y*B.x
\end{bmatrix}</script><p>叉乘的结果 $C$ 垂直于其他两个向量 $A$ 和 $B$ 构成的平面。<br>$A$ 和 $B$ 向量不需要相互垂直，不过如果它们相互垂直就可以通过所得的 $A B$ 和 $C$ 构成一个<strong>笛卡尔坐标系(cartesian coordinate system)</strong>（假设向量是单位向量）。<span class="label primary"> 点乘在创建一个坐标系非常有用。</span></p>
<p><strong>C++</strong>代码：</p>
<ul>
<li>作为一个类的成员函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Vector&ltT&gt <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Vector&ltT&gt  &v)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Vector&ltT&gt(</span><br><span class="line">            y * v.z - z * v.y,</span><br><span class="line">            z * v.x - x * v.z,</span><br><span class="line">            x * v.y - y * v.x</span><br><span class="line">            );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>作为一个函数：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T></span><br><span class="line"><span class="function">Vector&ltT&gt <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Vector&ltT&gt &v1, <span class="keyword">const</span> Vector&ltT&gt &v2)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Vector&ltT&gt(</span><br><span class="line">        v1.y * v2.z - v1.z * v2.y,</span><br><span class="line">        v1.z * v2.x - v1.x * v2.z,</span><br><span class="line">        v1.x * v2.y - v1.y * v2.x</span><br><span class="line">        );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>叉乘不满足<strong>交换律</strong>，$A \times B$ 不等于 $B \times A$<br>例如：$A \times B=(1,0,0)\times(0,1,0) = (0,0,1)$<br>但是，$B \times A=(0,1,0)\times(1,0,0)=(0,0,-1)$<br>所以如果$A \times B = C$那么$B \times A = -C$</p>
          </div>
<div class="note primary">
            <p>垂直于$AB$构成的平面的向量可以有两个朝向，而点乘出来的向量$C$的朝向也是根左右手坐标系来定的。这里我们以<strong>右手坐标系</strong>为例：</p><ul><li>食指指向$A$向量</li><li>中指指向$B$向量</li><li>大拇指的朝向就是$C$向量的正确朝向</li></ul><p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\cross.png " class="full-image" alt title style="max-width: none; width: 30%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
          </div>
<h4 id="Addition-amp-Subtraction"><a href="#Addition-amp-Subtraction" class="headerlink" title="Addition & Subtraction"></a>Addition & Subtraction</h4><p>向量的<strong>加(Addition)</strong>，<strong>减(Subtraction)</strong>,和乘以一个<strong>标量(scalar)</strong>就比较简单直接：</p>
<script type="math/tex; mode=display">
A+B=\begin{bmatrix}
A.x+B.x\\ 
A.y+B.y\\ 
A.z+B.z
\end{bmatrix}</script><script type="math/tex; mode=display">
A-B=\begin{bmatrix}
A.x-B.x\\ 
A.y-B.y\\ 
A.z-B.z
\end{bmatrix}</script><script type="math/tex; mode=display">
A*k=\begin{bmatrix}
A.x*k\\ 
A.y*k\\ 
A.z*k
\end{bmatrix}</script><p><strong>C++</strong>代码：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lttypename T&gt</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Vector&ltT&gt <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector&ltT&gt &v)<span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> Vector&ltT&gt(x + v.x, y + v.y, z + v.z);</span><br><span class="line">    }</span><br><span class="line">    Vector&ltT&gt <span class="keyword">operator</span> - (<span class="keyword">const</span> Vector&ltT&gt& v)<span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> Vector&ltT&gt(x - v.x, y - v.y, z - v.z);</span><br><span class="line">    }</span><br><span class="line">    Vector&ltT&gt <span class="keyword">operator</span> * (<span class="keyword">const</span> T& k) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> Vector&ltT&gt(x * k, y * k, z * k);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<hr>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><blockquote>
<p>Matrices</p>
</blockquote>
<p>简单来说，在3D应用中(非数学中的定义)，<strong>矩阵(Matrices)</strong>就是将所有<strong>变换信息(Transformations)</strong>如：移动(translation)，旋转(rotation)，缩放(scale)合并成单个结构，让变换变得简单。</p>
<p><strong>矩阵</strong>由<strong>行(rows)</strong>和<strong>列(columns)</strong>构成,一般描述为 $m \times n$ 矩阵，就是说 $m$ 行 $n$ 列矩阵, 例如一个 $3 \times 4$ 矩阵：</p>
<script type="math/tex; mode=display">
M = \begin{bmatrix}
1 & 3 & 2 & 7\\ 
 4& 2 & 0 & 3\\ 
1 & 5 & 6 & 4
\end{bmatrix}</script><div class="note primary">
            <p>一般我们用大写字母 $M, A, B$ 等等来表示一个矩阵。用下标 $i$ 和 $j$ 来表示矩阵中的某个元素。例如 $M_{ij}$ 就是表示矩阵 $M$ 的第 $i$ 行 $j$ 列 元素。</p>
          </div>
<h4 id="Square-Matrices"><a href="#Square-Matrices" class="headerlink" title="Square Matrices"></a>Square Matrices</h4><blockquote>
<p>方阵</p>
</blockquote>
<p>对于<strong>3D</strong>应用来说，我们最常用到的就是<strong>方阵(square matrices)</strong>,即<strong>行</strong>和<strong>列</strong>相等的矩阵。<br>在3D应用主要使用的方阵是 $3 \times 3$ 和 $4 \times 4$矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 3 & 2\\ 
 4& 2 & 0\\ 
1 & 5 & 6
\end{bmatrix}\tag{1}</script><script type="math/tex; mode=display">
\begin{bmatrix}
7& 2& 0& 4\\
2& 9& 5& 1\\
8& 7& 2& 1\\
3& 1& 0& 6
\end{bmatrix}\tag{2}</script><h1 id="GAMES101"><a href="#GAMES101" class="headerlink" title="GAMES101"></a>GAMES101</h1><blockquote>
<p>闫令琪 的 GAMES101-现代计算机图形学入门 笔记</p>
</blockquote>
<p>怎么判断画面好不好。从技术的角度来说，就是看画面够不够亮，如果全局关照做的好，画面就足够亮，看起来就很舒服。</p>
<blockquote>
<p>We learn Graphics, not Graphics APIs!</p>
</blockquote>
<p>从三维到二维我们管它叫投影，投影也是一个非常重要的变换。</p>
<hr>
<h2 id="各类矩阵"><a href="#各类矩阵" class="headerlink" title="各类矩阵"></a>各类矩阵</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>Rotation around <strong>X</strong>, <strong>Y</strong> or <strong>Z</strong></p>
<script type="math/tex; mode=display">
R_{x}(\theta)  = \begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 & cos \theta & -sin \theta & 0\\ 
0 & sin \theta & cos \theta & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
R_{y}(\theta)  = \begin{bmatrix}
cos \theta & 0 & sin \theta & 0\\ 
0 & 1 & 0 & 0\\ 
- sin \theta & 0 & cos \theta & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
R_{z}(\theta)  = \begin{bmatrix}
cos \theta & -sin \theta & 0 & 0\\ 
sin \theta & cos \theta & 0 & 0\\ 
0 & 0 & 1 & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><hr>
<h3 id="相机变换矩阵"><a href="#相机变换矩阵" class="headerlink" title="相机变换矩阵"></a>相机变换矩阵</h3><blockquote>
<p>View/Camera Transformation</p>
</blockquote>
<p>通过矩阵$M_{view}$来变换相机到指定位置：</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\camDir.jpg " class="full-image" alt title style="max-width: none; width: 30%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<ul>
<li>移动到原点</li>
<li>旋转朝前向量 $\vec{g}$ 到 <strong>-Z</strong>方向</li>
<li>旋转朝上向量 $\vec{t}$ 到 <strong>Y</strong>方向</li>
<li>旋转向量$\vec{g}\times\vec{t}$到<strong>X</strong>方向</li>
</ul>
<p>变换矩阵通过两个矩阵实现，通过矩阵$T_{view}$做平移</p>
<p>然后通过矩 $R_{view}$来做旋转</p>
<script type="math/tex; mode=display">
M_{view} = R_{view}T_{view}</script><p>先移动到原点：</p>
<script type="math/tex; mode=display">
T_{view}  = \begin{bmatrix}
1 & 0 & 0 & -x_{e}\\ 
0 & 1 & 0 & -y_{e}\\ 
0 & 0 & 1 & -z_{e}\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><p>然后选择到各个轴对齐：</p>
<script type="math/tex; mode=display">
R_{view} = \begin{bmatrix}
x_{\vec{g} \times \vec{t}} & y_{\vec{g} \times \vec{t}} & z_{\vec{g} \times \vec{t}} & 0 \\
x_{t} & y_{t} & z_{t} & 0 \\
x_{-\vec{g}} & y_{-\vec{g}} & z_{-\vec{g}} & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}</script><hr>
<h3 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h3><blockquote>
<p>Orthographic Projection</p>
</blockquote>
<p>将空间中任意的一个立方体(裁切空间)，移动到原点，然后将其<strong>X</strong>,<strong>Y</strong>,<strong>Z</strong>映射成<code>[-1, 1]</code>。构成一个<strong>标准立方体(Canonical Cube)</strong></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\ortho01.jpg " class="full-image" alt title style="max-width: none; width: 90%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<script type="math/tex; mode=display">
M_{ortho} = \begin{bmatrix}
\frac{2}{r-l}& 0 & 0 & 0\\ 
0 & \frac{2}{t-b} & 0 & 0\\ 
0 & 0 & \frac{2}{n-f} & 0\\ 
0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
1& 0 & 0 & -\frac{r+l}{2}\\ 
0 & 1 & 0 & -\frac{t+b}{2}\\ 
0 & 0 & 1 & -\frac{n+f}{2}\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><blockquote>
<p>Perspective Projection</p>
</blockquote>
<p>相比正交投影，透视投影更为常见。相比正交投影，透视投影多了一个矩阵$M_{persp\rightarrow ortho}$，即，将之前的裁切空间转换为一个正常的立方体，然后再像上面所提到的。再进行一次正交投影</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\persp01.jpg " class="full-image" alt title style="max-width: none; width: 75%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<script type="math/tex; mode=display">
M_{persp\rightarrow ortho} = \begin{bmatrix}
n & 0 & 0 & 0\\ 
0 & n & 0 & 0\\ 
0 & n+f & -nf & 0\\ 
0 & 0 & 1 & 0
\end{bmatrix}</script><p>最后在进行正交投影</p>
<script type="math/tex; mode=display">
M_{persp} = M_{ortho}M_{persp \rightarrow ortho}</script><p>透视投影还有个重要的元素。就是摄像机能看到的范围。其中两个重要的元素：</p>
<ul>
<li>vertical <strong>Field-of-view(垂直可视角度)</strong></li>
<li><strong>Aspect ratio(宽高比)</strong></li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\fov01.jpg " class="full-image" alt title style="max-width: none; width: 60%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>这两个概念定义了透视投影的<strong>视锥</strong></p>
<p>我们只要定义了这两个元素，就可以很简单的转化成<strong>正交投影中</strong>提到的<strong>远近(f,n)，左右(l,r)</strong>和<strong>上下(t,b)</strong></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\fov02.jpg " class="full-image" alt title style="max-width: none; width: 90%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><blockquote>
<p>Sampling</p>
</blockquote>
<p>采样在图形学中是一个非常非常重要的概念</p>
<div class="note primary">
            <p><strong>采样(Sampling)</strong>是什么概念：</p><ul><li>给你一个函数，它是连续的。然后我在不同的地方去问这个函数的值是多少;</li><li>例如<code>f(x)=sin(x)</code>，就去求<code>f(1),f(2),f(3)...</code>都是多少；</li><li>也就是说采样就是把一个函数<strong>离散化(discretize)</strong>的过程</li></ul>
          </div>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><blockquote>
<p>Geometry</p>
</blockquote>
<p>我们有两种方式来表示我们的几何：</p>
<p><strong>Implicity(隐式)</strong></p>
<ul>
<li>algebraic surface</li>
<li>level sets</li>
<li>distance functions</li>
<li>…</li>
</ul>
<p><strong>Explicit(显式)</strong></p>
<ul>
<li>point cloud</li>
<li>polygon mesh</li>
<li>subdivision, NURBS</li>
<li>…</li>
</ul>
<p>隐式几何不直接告诉你点的位置，而是告诉你它满足的关系。<br>例如一个球：<br>隐式的表示：<code>x^2 + y^2 + z^2 = 1</code><br>显式的表示：常见的方法就是把一个球拆成一堆三角面。</p>
<div class="note info">
            <p>隐式几何，对于判断一个点是否在这个几何面上（几何内，外）非常方便。</p>
          </div>
<p>没有一个好的办法可以解决所有的几何问题，所以我们要根据实际情况选择<strong>显式(Explicit)</strong>还是<strong>隐式(Implicity)</strong>的表示方法。</p>
<h1 id="LearnOpenGL"><a href="#LearnOpenGL" class="headerlink" title="LearnOpenGL"></a>LearnOpenGL</h1><blockquote>
<p><a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/</a></p>
</blockquote>
<h2 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h2><blockquote>
<p>基于物理的渲染(Physically Based Rendering)<br><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></p>
</blockquote>
<p>判断一种PBR光照模型是否基于物理，必须满足以下三个条件：</p>
<ol>
<li>基于<strong>微平面</strong>的表面模型;</li>
<li><strong>能量守恒</strong>;</li>
<li>应用基于物理的<strong>BRDF</strong></li>
</ol>
<h3 id="微平面模型"><a href="#微平面模型" class="headerlink" title="微平面模型"></a>微平面模型</h3><p>所有的PBR技术都基于微平面理论：<br>达到微观尺度之后任何平面都可以用被称为<strong>微平面(Microfacets)</strong>的细小镜面来进行描绘</p>
<div class="note info">
            <p>一个平面越是粗糙，这个平面上的微平面的排列就越混乱。这些微小镜面这样无序取向排列的影响就是，当我们特指镜面光/镜面反射时，入射光线更趋向于向完全不同的方向发散(Scatter)开来，进而产生出分布范围更广泛的镜面反射。而与之相反的是，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射</p>
          </div>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\microfacets_light_rays.png " class="full-image" alt title style="max-width: none; width: 65%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h3><p>微平面近似法使用了这样一种形式的<strong>能量守恒(Energy Conservation)</strong>：</p>
<ul>
<li>出射光线的能量永远<strong>不能超过</strong>入射光线的能量（发光面除外）。</li>
<li><strong>反射</strong>光与<strong>折射</strong>光它们二者之间是<strong>互斥的关系</strong>。</li>
</ul>
<p>为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光之间做出明确的区分。当一束光线碰撞到一个表面的时候，它就会分离成一个<strong>折射部分</strong>和一个<strong>反射部分</strong>。</p>
<div class="note primary">
            <p>通过物理学我们可以得知，光线实际上可以被认为是一束没有耗尽就<strong>不停向前运动的能量</strong>，而光束是通过<strong>碰撞</strong>的方式来<strong>消耗能量</strong>。每一种材料都是由无数微小的粒子所组成，这些粒子都能如下图所示一样与光线发生碰撞。这些粒子在每次的碰撞中都可以<strong>吸收光线</strong>所携带的一部分或者是全部的能量而后<strong>转变成为热量</strong>。<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\surface_reaction.png " class="full-image" alt title style="max-width: none; width: 35%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>光线会继续沿着（基本上）随机的方向发散，然后再和其他的粒子碰撞直至能量完全<strong>耗尽</strong>或者<strong>再次离开</strong>这个表面。而光线脱离物体表面后将会<strong>协同构成该表面的（漫反射）颜色</strong>。</p>
          </div>
<div class="note info">
            <p>不过在基于物理的渲染之中我们进行了简化，假设对平面上的每一点<strong>所有的折射光</strong>都会被完全吸收而<strong>不会散开</strong>。而有一些被称为<strong>次表面散射(Subsurface Scattering)</strong>技术的着色器技术将这个问题考虑了进去。</p>
          </div>
<div class="note warning">
            <p>对于<strong>金属(Metallic)</strong>表面,它们遵从的反射与折射原理是相同的，但是<strong>所有的折射光</strong>都会被<strong>直接吸收</strong>而不会散开，只留下<strong>反射光</strong>或者说镜面反射光。<span class="label warning">金属表面<b>不会显示出漫反射颜色</b></span>。因此它们两者在PBR渲染管线中被区别处理。</p>
          </div>
<h3 id="反射率方程"><a href="#反射率方程" class="headerlink" title="反射率方程"></a>反射率方程</h3><p>基于物理的渲染所坚定的遵循的是一种被称为<strong>反射率方程(The Reflectance Equation)</strong>的渲染方程的特化版本。<br>要正确的理解PBR 很重要的一点就是要首先透彻的理解反射率方程：</p>
<script type="math/tex; mode=display">
L_{o}(p,\omega) = \int_{\Omega}f_{r}(p, \omega_{i}, \omega_{o})L_{i}(p, \omega_{i})n \cdot \omega_{i} d \omega_{i}</script><p><strong>辐射率(Radiance)</strong>: $L$, 量化单一方向上发射来的光线的大小或者强度;</p>
<p><strong>立体角(Solid angle)</strong>: $\omega$, 它可以为我们描述投射到单位球体上的一个截面的大小或者面积;<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\solid_angle.png " class="full-image" alt title style="max-width: none; width: 25%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
<p><strong>辐射强度(Radiant intensity)</strong>: $I$, 一个光源向每单位立体角所投送的辐射通量。</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\radiant_intensity.png " class="full-image" alt title style="max-width: none; width: 20%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>辐射强度</strong>公式如下所示：</p>
<script type="math/tex; mode=display">
I = \frac{d\phi }{d\omega }</script><p>其中$\phi$ 表示<strong>辐射通量</strong>， $\omega$ 表示<strong>立体角</strong></p>
<p>在理解了辐射通量，辐射强度与立体角的概念之后，我们终于可以开始讨论<strong>辐射率</strong>的方程式了。这个方程表示的是，一个拥有<strong>辐射强度</strong>$\phi$的光源在<strong>单位面积</strong>$A$，<strong>单位立体角</strong>$\omega$上的辐射出的总能量：</p>
<p><strong>辐射率</strong>公式如下所示：</p>
<script type="math/tex; mode=display">
L = \frac{d^2\phi}{dAd\omega\cos\theta }</script><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\radiance.png " class="full-image" alt title style="max-width: none; width: 30%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>如果我们把立体角$\omega$和面积$A$看作是<strong>无穷小</strong>的，那么我们就能用辐射率来表示<strong>单束光线</strong>穿过空间中的<strong>一个点</strong>的通量。这就使我们可以计算得出作用于单个（片段）点上的<strong>单束光线的辐射率</strong>，我们实际上把立体角$\omega$转变为<strong>方向向量</strong>$\omega$然后把面$A$转换为<strong>点</strong>$p$。这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用了。</p>
<p>让我们再回过头来看看<strong>反射率方程(The Reflectance Equation)</strong>:</p>
<script type="math/tex; mode=display">
L_{o}(p,\omega) = \int_{\Omega}f_{r}(p, \omega_{i}, \omega_{o})L_{i}(p, \omega_{i})n \cdot \omega_{i} d \omega_{i}</script><ul>
<li>现在知道了$L$代表某个无限小的立体角$\omega_{i}$在某个点上的辐射率，而立体角可以视作是<strong>入射方向向量</strong></li>
<li>利用光线和平面间的入射角的余弦值$\cos \theta$来计算能量，亦即从辐射率公式$L$转化至反射率公式时的$n\cdot\omega_{i}$。</li>
<li>$\omega_{o}$ 表示观察方向。反射率计算公式计算了点$p$在观察方向上被反射出来的辐射率的总和</li>
<li>基于反射率公式是围绕所有入射辐射率的总和，所以我们需要计算的就不只是是单一的一个方向上的入射光，而是一个以点$p$为球心的半球领域$\Omega$内所有方向上的入射光.为了计算某些面积的值我们会需要用到一种称为<strong>积分(Integral)</strong>的数学手段，也就是反射率公式中的符号$\int$,它的运算包含了半球领域$\Omega$内所有入射方向上的$d\omega_{i}$</li>
</ul>
<p>现在唯一剩下的未知符号就是$f_{r}$了，它被称为<strong>BRDF</strong>，或者<strong>双向反射分布函数(Bidirectional Reflective Distribution Function)</strong> ，它的作用是基于表面材质属性来对入射辐射率进行缩放或者加权。</p>
<h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><blockquote>
<p>双向反射分布函数(bidirectional reflective distribution function)</p>
</blockquote>
<p>BRDF可以近似的求出每束光线对一个给定了材质属性的平面上最终反射出来的光线所作出的贡献程度。</p>
<blockquote>
<p><strong>Blinn-Phong</strong>光照模型也被认为是一个<strong>BRDF</strong>。然而由于Blinn-Phong模型并没有遵循能<strong>量守恒定律</strong>，因此它不被认为是<strong>基于物理的渲染</strong>。</p>
</blockquote>
<p>现在已经有很好几种BRDF都能近似的得出物体表面对于光的反应。<br>但是几乎所有实时渲染管线使用的都是一种被称为Cook-Torrance BRDF模型:</p>
<script type="math/tex; mode=display">
f_{cook_torrance} = \frac{DFG}{4(\omega_{o} \cdot n)(\omega_{i} \cdot n)}</script><ul>
<li><strong>正态分布函数(Normal Distribution Function)</strong>：估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。这是用来估算微平面的主要函数。</li>
<li><strong>菲涅尔方程(Fresnel Equation)</strong>：菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率。</li>
<li><strong>几何函数(Geometry Function)</strong>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li>
</ul>
<p>我们将会采用Epic Games在Unreal Engine 4中所使用的函数:</p>
<ul>
<li><strong>D</strong>: Trowbridge-Reitz GGX</li>
<li><strong>F</strong>: Fresnel-Schlick approximation</li>
<li><strong>G</strong>: Smith’s Schlick-GGX</li>
</ul>
<h4 id="正态分布函数"><a href="#正态分布函数" class="headerlink" title="正态分布函数"></a>正态分布函数</h4><blockquote>
<p>Normal Distribution Function</p>
</blockquote>
<p><strong>正态分布函数</strong>从统计学上近似的表示了与某些（中间）向量$h$<strong>取向一致</strong>的微平面的<strong>比率</strong>。</p>
<script type="math/tex; mode=display">
NDF_{GGXTR}(n, h, a) = \frac{a^2}{\pi ((n \cdot h)^2 (a^2 - 1) + 1)^2}</script><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\ndf.png " class="full-image" alt title style="max-width: none; width: 65%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">D_GGX_TR</span><span class="params">(vec3 N, vec3 H, <span class="keyword">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> a2     = a*a;</span><br><span class="line">    <span class="keyword">float</span> NdotH  = max(dot(N, H), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> NdotH2 = NdotH*NdotH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> nom    = a2;</span><br><span class="line">    <span class="keyword">float</span> denom  = (NdotH2 * (a2 - <span class="number">1.0</span>) + <span class="number">1.0</span>);</span><br><span class="line">    denom        = PI * denom * denom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h4><blockquote>
<p>Geometry Function</p>
</blockquote>
<p><strong>几何函数</strong>从统计学上近似的求得了<strong>微平面间相互遮蔽的比率</strong>，这种相互遮蔽会损耗光线的能量。</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\geometry_shadowing.png " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<script type="math/tex; mode=display">
G_{SchlickGGX}(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k}</script><p>这里的$k$是$\alpha$基于几何函数是针对<strong>直接光照</strong>还是针对<strong>IBL光照</strong>的<strong>重映射(Remapping)</strong> :</p>
<script type="math/tex; mode=display">
k_{direct} = \frac{(\alpha + 1)^2}{8}</script><script type="math/tex; mode=display">
k_{IBL} = \frac{\alpha^2}{2}</script><p>为了有效的估算几何部分，需要将<strong>观察方向（几何遮蔽(Geometry Obstruction)）</strong>和<strong>光线方向（几何阴影(Geometry Shadowing)）</strong>都考虑进去。我们可以使用<strong>史密斯法(Smith’s method)</strong>来把两者都纳入其中：</p>
<script type="math/tex; mode=display">
G(n, v, l, k) = G_{sub}(n, v, k)G_{sbu}(n, l, k)</script><p>c</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySchlickGGX</span><span class="params">(<span class="keyword">float</span> NdotV, <span class="keyword">float</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> nom   = NdotV;</span><br><span class="line">    <span class="keyword">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GeometrySmith</span><span class="params">(vec3 N, vec3 V, vec3 L, <span class="keyword">float</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> NdotV = max(dot(N, V), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> NdotL = max(dot(N, L), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> ggx1 = GeometrySchlickGGX(NdotV, k);</span><br><span class="line">    <span class="keyword">float</span> ggx2 = GeometrySchlickGGX(NdotL, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h4><blockquote>
<p>Fresnel Equation</p>
</blockquote>
<p><strong>菲涅尔方程</strong>描述的是被反射的光线对比光线被折射的部分所占的比率，这个比率会随着我们观察的角度不同而不同.<br>当垂直观察的时候，任何物体或者材质表面都有一个<strong>基础反射率(Base Reflectivity)</strong>，但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。</p>
<script type="math/tex; mode=display">
F_{Schlick}(n, v, F_{0}) = F_{0} + (1 - F_{0})(1 - (n \cdot v))^5</script><p>$F_{0}$表示平面的基础反射率，它是利用所谓<strong>折射指数(Indices of Refraction)</strong>或者说<strong>IOR</strong>计算得出的</p>
<p>其中一个问题是<code>Fresnel-Schlick</code>近似仅仅对<strong>电介质</strong>或者说<strong>非金属表面</strong>有定义。对于<strong>导体表面（金属）</strong>，使用它们的折射指数计算基础折射率并不能得出正确的结果，这样我们就需要使用一种不同的菲涅尔方程来对导体表面进行计算。<br>所以我们预先计算出平面对于法向入射$F_{0}$的反应（处于0度角，好像直接看向表面一样）然后基于相应观察角的<code>Fresnel-Schlick</code>近似对这个值进行插值，用这种方法来进行进一步的估算。这样我们就能对金属和非金属材质使用同一个公式了。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">fresnelSchlick</span><span class="params">(<span class="keyword">float</span> cosTheta, vec3 F0)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="number">1.0</span> - F0) * <span class="built_in">pow</span>(<span class="number">1.0</span> - cosTheta, <span class="number">5.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><hr>
<h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>方向向量就会像这样来表示：<code>vec4(0.2f, 1.0f, 0.3f, 0.0f)</code>。<br>这也可以作为一个<strong>快速检测光照类型</strong>的工具：<br>你可以检测w分量是否等于1.0，来检测它是否是光的<strong>位置</strong>向量；<br>w分量等于0.0，则它是光的<strong>方向</strong>向量，这样就能根据这个来调整光照计算了：</p>
<hr>
<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><blockquote>
<p>Point Light</p>
</blockquote>
<ul>
<li><strong>衰减(Attenuation)</strong>：</li>
</ul>
<script type="math/tex; mode=display">
F_{att} = \frac{1.0}{K_{c} + K_{l} * d + K_{q} * d^2}</script><ul>
<li>$d$ 代表片元于光源的距离；</li>
<li>$K_{c}$ 常数项，通常保持<code>1.0</code>，主要作用保证分母不会比<code>1</code>小，否则某些距离上它反而会增强；</li>
<li>$K_{l}$ 一次项， 于距离相乘，以线性的方式减少强度；</li>
<li>$K_{q}$ 二次项， 于距离的平方相乘， 以二次递减的方式减少强度。</li>
</ul>
<p><strong>经验设置：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">距离</th>
<th style="text-align:left">常数项</th>
<th style="text-align:left">一次项</th>
<th style="text-align:left">二次项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.7</td>
<td style="text-align:left">1.8</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.35</td>
<td style="text-align:left">0.44</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.22</td>
<td style="text-align:left">0.20</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.14</td>
<td style="text-align:left">0.07</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.09</td>
<td style="text-align:left">0.032</td>
</tr>
<tr>
<td style="text-align:left">65</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.07</td>
<td style="text-align:left">0.017</td>
</tr>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.045</td>
<td style="text-align:left">0.0075</td>
</tr>
<tr>
<td style="text-align:left">160</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.027</td>
<td style="text-align:left">0.0028</td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.022</td>
<td style="text-align:left">0.0019</td>
</tr>
<tr>
<td style="text-align:left">325</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.014</td>
<td style="text-align:left">0.0007</td>
</tr>
<tr>
<td style="text-align:left">600</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.007</td>
<td style="text-align:left">0.0002</td>
</tr>
<tr>
<td style="text-align:left">3250</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">0.0014</td>
<td style="text-align:left">0.000007</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h3><blockquote>
<p>Spotlight</p>
</blockquote>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\light_casters_spotlight_angles.png " class="full-image" alt title style="max-width: none; width: 40%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<ul>
<li><strong>LightDir</strong>: 从片元指向光源的向量；</li>
<li><strong>SpotDir</strong>: 聚光所指向的方向；</li>
<li><strong>Phi</strong> $\phi$: 指定的聚光半径的切光角；</li>
<li><strong>Theta</strong> $\theta$: LightDir向量和SpotDir向量的夹角。</li>
</ul>
<p><strong>平滑/软化边缘</strong></p>
<p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个内<strong>圆锥(Inner Cone)</strong>和一个<strong>外圆锥(Outer Cone)</strong>：<br>如果一个片段处于<strong>内外圆锥之间</strong>，将会给它计算出一个<code>0.0</code>到<code>1.0</code>之间的强度值。如果片段在<strong>内圆锥之内</strong>，它的强度就是<code>1.0</code>，如果在<strong>外圆锥之外</strong>强度值就是<code>0.0</code>。</p>
<script type="math/tex; mode=display">
I = \frac{\theta-\lambda}{\gamma}</script><ul>
<li>$\epsilon$ 是内圆锥和外圆锥的余弦值差($\epsilon = \phi - \gamma$)。最终的$I$值就是当前片元聚光的强度</li>
</ul>
<hr>
<h2 id="帧缓存"><a href="#帧缓存" class="headerlink" title="帧缓存"></a>帧缓存</h2><blockquote>
<p>Framebuffers</p>
</blockquote>
<p>创建一个帧缓存：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fbo;</span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &fbo); <span class="comment">// 创建帧缓存</span></span><br><span class="line"></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, fbo); <span class="comment">// 绑定为激活的帧缓存</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    进行一些操作</span></span><br><span class="line"><span class="comment">    之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中</span></span><br><span class="line"><span class="comment">    即，离屏渲染(Off-screen Rendering)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>); <span class="comment">// 解除绑定，再次激活默认帧缓存</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>一个完整的帧缓存需要满足以下条件：</p>
<ul>
<li>附加至少一个<strong>缓存</strong>（颜色、深度或模板）；</li>
<li>至少有一个颜色<strong>附件</strong>(Attachment)；</li>
<li>所有的<strong>附件</strong>都必须是<strong>完整</strong>的（保留了内存）；</li>
<li>每个缓存都应该有<strong>相同</strong>的<strong>样本数</strong>。</li>
</ul>
<div class="note primary">
            <p>检查帧缓存是否完整：<br><code>if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</code></p>
          </div>
<div class="note info">
            <p>由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。<br>出于这个原因，渲染到一个不同的帧缓冲被叫做<strong>离屏渲染(Off-screen Rendering)</strong>。</p>
          </div>
<p>在完成所有帧缓存操作后，删除帧缓存对象：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteFramebuffers(<span class="number">1</span>, &fbo);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><strong>附件</strong>是一个内存位置，它能够作为帧缓存的一个缓存，可以将它想象为一个图像。当创建一个附件的时候又两个选项：</p>
<ul>
<li><strong>纹理(Texture)</strong></li>
<li><strong>渲染缓存对象(Renderbuffer Object)</strong></li>
</ul>
<h3 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h3><blockquote>
<p>Texture attachments</p>
</blockquote>
<p>为帧缓冲创建一个纹理和创建一个普通的纹理差不多：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会<strong>写入到这个纹理中</strong>，就想它是一个普通的<strong>颜色</strong>,<strong>深度</strong>或<strong>模板</strong>缓冲一样。</p>
          </div>
<p>现在我们已经创建好一个纹理了，要做的最后一件事就是将它附加到帧缓冲上了：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>glFramebufferTexture2D</strong>参数：</p>
<ul>
<li><strong>target</strong>: 帧缓存的目标（绘制、读取或者都）；</li>
<li><strong>attachment</strong>: 附加的附件类型，颜色，深度和模板；</li>
<li><strong>textarget</strong>: 附加的纹理类型；</li>
<li><strong>texture</strong>: 附加的纹理；</li>
<li><strong>level</strong>: Mipmap等级；</li>
</ul>
<h3 id="渲染缓存对象附件"><a href="#渲染缓存对象附件" class="headerlink" title="渲染缓存对象附件"></a>渲染缓存对象附件</h3><blockquote>
<p>Renderbuffer Object</p>
</blockquote>
<p><strong>渲染缓存对象</strong>是一个真正的缓冲，即一系列的<strong>字节</strong>、<strong>整数</strong>、<strong>像素</strong>等。<br>它会将数据储存为<strong>OpenGL原生的渲染格式</strong>，它是为离屏渲染到帧缓存<strong>优化过</strong>的。</p>
<div class="note info">
            <p>渲染缓存对象直接将所有的渲染数据储存到它的缓存中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓存对象通常都是<strong>只写</strong>的，所以你<strong>不能读取它们</strong>（比如使用纹理访问）。</p>
          </div>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个渲染缓冲对象：</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rbo;</span><br><span class="line">glGenRenderbuffers(<span class="number">1</span>, &rbo);</span><br><span class="line"><span class="comment">// 我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的rbo</span></span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, rbo);</span><br><span class="line"><span class="comment">// 创建一个深度和模板渲染缓存对象：</span></span><br><span class="line">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 这里我们选择`GL_DEPTH24_STENCIL8`作为内部格式，它封装了**24位的深度**和**8位的模板缓冲**。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一件事就是附加这个渲染缓冲对象:</span></span><br><span class="line">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>由于渲染缓存对象通常都是只写的，它们会经常用于<strong>深度</strong>和<strong>模板</strong>附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，<strong>只关心深度和模板测试。</strong></p>
          </div>
<hr>
<h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><blockquote>
<p>Normal</p>
</blockquote>
<h3 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h3><blockquote>
<p>Tangent Space</p>
</blockquote>
<p>法线贴图中的<strong>法线向量</strong>定义在<strong>切线空间</strong>中，在切线空间中，法线永远指着正z方向。<br>切线空间是位于三角形表面之上的空间：<strong>法线相对于单个三角形的本地参考框架</strong></p>
<div class="note primary">
            <p>切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的z方向和表面的法线方向对齐。</p>
          </div>
<h2 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h2><blockquote>
<p>Parallax</p>
</blockquote>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\parallax_mapping_scaled_height.png " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<ul>
<li><strong>红线</strong>是高度图的立体表现；</li>
<li>$\vec{V}$(黄线) 代表观察方向；</li>
<li>观察者会在点$A$看到表面；</li>
<li>而使用<strong>视差贴图</strong>后，观察者会在点$B$看到表面；</li>
<li>在$A$位置上的<strong>Fragment</strong>不再使用点$A$的纹理坐标而是使用点$B$的。</li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\parallax_mapping_scaled_height2.png " class="full-image" alt title style="max-width: none; width: 50%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>如何从点$A$得到点$B$的纹理坐标：</p>
<ol>
<li>将观察向量$\vec{V}$的长度缩放到高度贴图在点$A$出处的采样值$H(A)$,得到$\vec{P}$;</li>
<li>随后算出$\vec{P}$以及该向量与平面对齐的坐标，作为纹理坐标的偏移量；</li>
</ol>
<div class="note warning">
            <p>这个技巧在大多数时候都没问题，但点$B$是粗略估算得到的。<br>当表面的高度变化很快的时候，看起来就不会真实，因为向量$\vec{P}$最终不会和$B$接近。<br>就像下图这样：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\parallax_mapping_incorrect_p.png " class="full-image" alt title style="max-width: none; width: 50%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
          </div>
<div class="note info">
            <p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从$\vec{P}$获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间$\vec{P}$向量的<strong>x</strong>和<strong>y</strong>元素总是与纹理表面对齐。我们还是在切线空间中实现视差贴图。</p>
          </div>
<hr>
<h2 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h2><blockquote>
<p>Deferred Rendering</p>
</blockquote>
<p><strong>正向渲染(Forward Rendering)</strong>，它的渲染方式非常直接：<br>在场景中，根据光源的光照逐个渲染物体。对<strong>每一个光源</strong>，<strong>每一个需要渲染的片段</strong>进行迭代。<br>并且，大部分片段着色器的输出都会<strong>被之后的输出覆盖</strong>，（多个物体重合在一个像素上）浪费大量的运行时间。</p>
<p><strong>延迟渲染(Deferred Rendering)</strong>，为了解决上述问题诞生：</p>
<ul>
<li><strong>延迟(Defer)</strong>大部分计算量非常大的渲染(像是光照)到<strong>后期进行处理</strong>；</li>
<li>在第一个<strong>几何处理阶段(Geometry Pass)</strong>中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做<strong>G缓冲(G-buffer)</strong>的纹理中；</li>
</ul>
<p>一帧中G缓冲的内容：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\deferred_g_buffer.png " class="full-image" alt title style="max-width: none; width: 65%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
<hr>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><blockquote>
<p>Gaussian Blur</p>
</blockquote>
<p>高斯模糊基于高斯曲线，高斯曲线通常被描述为一个钟形曲线，中间的值达到最大化，随着距离的增加，两边值不断减少。</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\bloom_gaussian.png " class="full-image" alt title style="max-width: none; width: 35%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>要实现高斯模糊过滤我们需要一个二维四方形作为权重，从这个<strong>二维高斯曲线方程</strong>中去获取它。然而这个过程有个问题，就是很快会消耗极大的性能。<br><span class="label warning">以一个**32×32**的模糊kernel为例，我们必须对每个fragment从一个纹理中采样1024次！</span></p>
<p>高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：<br><strong>一个描述水平权重，另一个描述垂直权重。</strong><br>我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。<br><span class="label success">利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做**32+32**次采样，不再是1024了！这叫做两步高斯模糊。</span></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\bloom_gaussian_two_pass.png " class="full-image" alt title style="max-width: none; width: 80%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>代码：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">bool</span> horizontal;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> weight[<span class="number">5</span>] = <span class="keyword">float</span>[] (<span class="number">0.227027</span>, <span class="number">0.1945946</span>, <span class="number">0.1216216</span>, <span class="number">0.054054</span>, <span class="number">0.016216</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vec2 tex_offset = <span class="number">1.0</span> / textureSize(image, <span class="number">0</span>); <span class="comment">// gets size of single texel</span></span><br><span class="line">    vec3 result = texture(image, TexCoords).rgb * weight[<span class="number">0</span>]; <span class="comment">// current fragment's contribution</span></span><br><span class="line">    <span class="keyword">if</span>(horizontal)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < <span class="number">5</span>; ++i)</span><br><span class="line">        {</span><br><span class="line">            result += texture(image, TexCoords + vec2(tex_offset.x * i, <span class="number">0.0</span>)).rgb * weight[i];</span><br><span class="line">            result += texture(image, TexCoords - vec2(tex_offset.x * i, <span class="number">0.0</span>)).rgb * weight[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < <span class="number">5</span>; ++i)</span><br><span class="line">        {</span><br><span class="line">            result += texture(image, TexCoords + vec2(<span class="number">0.0</span>, tex_offset.y * i)).rgb * weight[i];</span><br><span class="line">            result += texture(image, TexCoords - vec2(<span class="number">0.0</span>, tex_offset.y * i)).rgb * weight[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    FragColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这意味着我们如果对一个图像进行模糊处理，至少需要两步。<br>具体来说，我们将实现像乒乓球一样的帧缓冲来实现高斯模糊:</p>
<ol>
<li>先创建<strong>一对帧缓存</strong>；</li>
<li>场景纹理的<strong>第一个缓存</strong>中进行模糊（水平模糊）</li>
<li>然后在把第一个帧缓存的<strong>颜色缓存</strong>放进<strong>第二个帧缓存</strong>进行模糊（垂直模糊）</li>
<li>循环往复。。。</li>
</ol>
<p>这样我们可以对任意图像进行任意次模糊处理；高斯模糊循环次数越多，模糊的强度越大。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr>
<h2 id="Ray-Marching"><a href="#Ray-Marching" class="headerlink" title="Ray Marching"></a>Ray Marching</h2><blockquote>
<p>光线行进</p>
</blockquote>
<p><strong>RayMarching</strong>也是从摄像机向屏幕的每一个像素发射出<strong>射线(Ray)</strong>。<br>直到射线接触（小于一定距离）到了物体表面。然后根据该位置的一些信息进行绘制。</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\RayMarching.png " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>而R<strong>ayMarching</strong>的特点就是:<br><strong>射线(Ray)</strong>在前进过程中，需要检测当前<strong>步(Step)</strong>的<strong>位置</strong>（下图点<code>p</code>）于整个场景中所有物体表面的距离。<strong>取最小值</strong>；<br>使用该值，作为下一步<strong>前进的距离</strong>，<br>循环往复。。。<br>直到前进的位置接触到某个表面（准确来说，是于某个表面距离足够小）。</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\08_displacement_05.jpg " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="如何进行检测"><a href="#如何进行检测" class="headerlink" title="如何进行检测"></a>如何进行检测</h3><blockquote>
<p>RayMarch()</p>
</blockquote>
<p>就是从射线的起始点开始，通过<strong>起始点</strong>和<strong>射线方向</strong>让它for循环逐步向前，在每次的循环中，进行一些条件判断判断：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STEPS 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DEPTH 200.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_SURFACE_DISTANCE 0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RayMarch</span><span class="params">(vec3 ray_origin, vec3 ray_direction)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> depth = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<max_steps; i++)< span><br><span class="line">    {</span><br><span class="line">        vec3 p = ray_origin + ray_direction * depth;</span><br><span class="line">        <span class="keyword">float</span> d = GetMinDistance(p);</span><br><span class="line">        depth += d;</span><br><span class="line">        <span class="keyword">if</span>(depth>MAX_DEPTH || d<min_surface_distance)< span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">}</span><br></min_surface_distance)<></span></max_steps;></span></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li><code>MAX_STEPS</code>是对射线前进的次数进行限制，即超过<code>100</code>停止检测；</li>
<li><code>MAX_DEPTH</code>是对射线前进距离的，即距离超过<code>200</code>个单位也停止检测；</li>
<li><code>MIN_SURFACE_DISTANCE</code>是表面距离的判断，我们设定，如果当前位置获取到的最小距离小于<code>0.01</code>我们就认为当前位置已经触碰到表面了；</li>
<li><code>GetMinDistance()</code>就是根据当前位置<code>p</code>来遍历整个场景，得到与之最近的物体表面的距离<code>d</code></li>
</ul>
<h3 id="如何获取最小距离"><a href="#如何获取最小距离" class="headerlink" title="如何获取最小距离"></a>如何获取最小距离</h3><blockquote>
<p>GetMinDistance()</p>
</blockquote>
<p>接着我们上面提到的函数<code>GetMinDistance()</code></p>
<div class="note primary">
            <p><strong>RayMarching</strong>还有一个要了解的点，就是里面的几何模型，都是<strong>隐式几何</strong>，是通过<strong>距离函数(Distance Functions)</strong>来定义几何位置与形状。</p>
          </div>
<p>例如最简单球体的距离函数代码：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sphere</span><span class="params">(vec3 p, vec3 center, <span class="keyword">float</span> radius)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">return</span> (length(p-center) - radius);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>p</code>表示当前的检测位置，<code>center</code>为球体中心<code>radius</code>则是半径</p>
<p>当然，表示一个<strong>地面</strong>的距离函数更为简单。当前位置<code>p</code>于地面的距离就是它的<strong>垂直高度</strong>。<br>所以如果我们的地面水平高度为<code>0</code>,那<code>p.y</code>可以直接表示为于地面距离</p>
<p>所以如果一个场景里，只有一个<strong>球体(Sphere)</strong>,和一个水平高度为<code>0</code>的<strong>地面</strong>，<code>GetMinDistance()</code>的内容：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetMinDistance</span><span class="params">(vec3 p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> sphereDist = Sphere(p, vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>), <span class="number">0.8</span>);</span><br><span class="line">    <span class="keyword">float</span> groundDist = p.y; <span class="comment">// p.y - 0.0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> d = min(sphereDist, groundDist);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分别计算出与<strong>球体</strong>和<strong>地面</strong>的距离，然后返回<strong>更小的距离</strong>。</p>
<hr>
<h2 id="军团要塞NPR渲染"><a href="#军团要塞NPR渲染" class="headerlink" title="军团要塞NPR渲染"></a>军团要塞NPR渲染</h2><blockquote>
<p>Non-photorealistic shading in <em>Tram Fortress2</em><br><a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf" target="_blank" rel="noopener">https://steamcdn-a.akamaihd.net/apps/valve/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf</a></p>
</blockquote>
<script type="math/tex; mode=display">
k_{d}
\begin{bmatrix}
a(\vec{n})+\sum_{i=1}^{L}c_{i}w((\alpha(\vec{n} \cdot \vec{l_{i}}) + \beta )^{\gamma })
\end{bmatrix}</script><ul>
<li>$L$ 表示灯关数量, $i$ 示灯关序号(index), $c_{i}$ 则表示该灯关的颜色；</li>
<li>$k_{d}$为物体的固有颜色，即<strong>Albedo</strong>；</li>
<li>$\vec{n} \cdot \vec{l_{i}}$ 是基于第 $i$ 个灯关的，传统的<strong>Lambert</strong>光照；</li>
<li>常量$\alpha, \beta, \gamma$ 用于控制<strong>Lambert</strong>光照的参数；</li>
<li>$a()$是一个计算环境与每个像素法线关系的函数；</li>
<li>$w()$是一个将RGB颜色重新映射到<code>[0,1]</code>的函数。</li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\TF2npr01.jpg " class="full-image" alt title style="max-width: none; width: 65%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\TF2npr02.jpg " class="full-image" alt title style="max-width: none; width: 65%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="EA次表面散射：快速，廉价"><a href="#EA次表面散射：快速，廉价" class="headerlink" title="EA次表面散射：快速，廉价"></a>EA次表面散射：快速，廉价</h2><blockquote>
<p>Fast, Cheap and Convincing Subsurface Scattering Look<br><strong>次表面散射（subsurface scattering）</strong>：当光线照射到半透明材料的表面时，一部分在内部传播，在分子之间反弹，直到它找到出路。这通常会导致在特定点吸收的光在其他地方重新发射。</p>
</blockquote>
<p>本笔记中描述的方法基于<strong>ColinBarré-Brisebois</strong>和<strong>Marc Bouchard</strong>在<strong>GDC 2011</strong>上提出的解决方案：<br><a href="https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/" target="_blank" rel="noopener">Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look</a><br>他们的解决方案被整合到Frostbite 2引擎中。</p>
<div class="note success">
            <p><strong>Alan Zucconi</strong>在<strong>Unity</strong>中的实现：<br><a href="https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/" target="_blank" rel="noopener">Fast Subsurface Scattering in Unity (Part 1)</a><br><a href="https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/" target="_blank" rel="noopener">Fast Subsurface Scattering in Unity (Part 2)</a></p>
          </div>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>我们不希望依赖于额外的<strong>深度图(depth maps)</strong>和<strong>贴图空间模糊(texture-sapce blurs)</strong><ul>
<li>需要<strong>更多的内存</strong>(深度图等)</li>
<li>需要<strong>大量的计算</strong>(贴图模糊等)</li>
</ul>
</li>
<li>本质上，合理的半透明材质，光线会在物体内传播：<ul>
<li>受物体的<strong>厚度</strong>影响</li>
<li>受视角和灯光的<strong>扩散/衰减</strong>影响</li>
</ul>
</li>
<li>我们只需要一个<strong>简单的内部扩散</strong>表示<ul>
<li>即使不准确，但是能得到一个比较可信的结果</li>
<li>而且，如果实现效果廉价，我们就可以自由的到处使用</li>
</ul>
</li>
</ul>
<h3 id="厚度图"><a href="#厚度图" class="headerlink" title="厚度图"></a>厚度图</h3><blockquote>
<p>Thickness</p>
</blockquote>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\thickness.jpg " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<ul>
<li>依赖于<strong>Ambient Occlusion</strong>计算这些信息：<ol>
<li>反转表面法线</li>
<li>渲染AO</li>
<li>反向颜色存储成一张贴图</li>
</ol>
</li>
</ul>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><blockquote>
<p>Implementation Details</p>
</blockquote>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\directAndTranslucency.jpg " class="full-image" alt title="Direct and Translucency Lighting Vectors" style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>Code:</strong><br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half3 vLTLight = vLight + vNormal * fLTDistortion;</span><br><span class="line">half fLTDot = <span class="built_in">pow</span>(saturate(dot(vEye, -vLTLight)), iLTPower) * fLTScale;</span><br><span class="line">half3 fLT = fLightAttenuation * (fLTDot + fLTAmbient) * fLTThickness;</span><br><span class="line">outColor.rgb += cDiffuseAlbedo * cLightDiffuse * fLT;</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li><strong>fLTDistortion:</strong> <strong>次表面失真(Subsurface Distortion)</strong>，便宜表面法线，表现更多的菲涅尔效果</li>
<li><strong>fLTAmbient:</strong> <strong>环境强度</strong>。所有角度可见，半透明材质前后都会影响；</li>
<li><strong>iLTPower:</strong> 直接透明的<strong>幂(power)</strong>；</li>
<li><strong>fLTThickness:</strong> 预计算的本地<strong>厚度图(ThicknessMap)</strong>，用于间接和直接透明。通过计算表面厚度的变化进行<strong>衰减</strong>。</li>
<li><strong>fLTScale:</strong> <strong>直射/背面</strong> 半透明<strong>强度</strong></li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\allTogether.jpg " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="地面高度混合"><a href="#地面高度混合" class="headerlink" title="地面高度混合"></a>地面高度混合</h2><p><strong>参考链接：</strong><a href="https://www.gamasutra.com/blogs/AndreyMishkinis/20130716/196339/Advanced_Terrain_Texture_Splatting.php" target="_blank" rel="noopener">Advanced_Terrain_Texture_Splatting</a></p>
<p><strong>MASK混合</strong><br>常见的最基础的混合，通过<code>mask</code>混合：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">blend</span><span class="params">(float4 texture1, <span class="keyword">float</span> mask1, float4 texture2, <span class="keyword">float</span> mask2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> texture1.rgb * mask1 + texture2.rgb * mask2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend01.png " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>Unity3D</strong>的标准地形混合，混合得<strong>很柔和</strong>，但是<strong>不自然</strong><br>因为，不可能存在既有石板，又有碎石的材质。碎石应该自然的滑落到石板的缝隙之中</p>
<p><strong>高度图混合</strong><br>在这种混合中，我们加入了<strong>高度图</strong>(贴图的alpha通道为高度图)：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">blend</span><span class="params">(float4 texture1, <span class="keyword">float</span> mask1, float4 texture2, <span class="keyword">float</span> mask2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> texture1.a > texture2.a ? texture1.rgb : texture2.rgb;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend02.png " class="full-image" alt title style="max-width: none; width: 70%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>如上图所示，红线为石板的高度，蓝线为碎石的高度，我们只显示高出的材质，就可以达到下图的效果：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend03.png " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
<p><strong>高度图+Mask混合</strong><br>这样的效果会相对自然，但是并没有使用到mask，所以我们在上面的代码上加上mask：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">blend</span><span class="params">(float4 texture1, <span class="keyword">float</span> mask1, float4 texture2, <span class="keyword">float</span> mask2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> texture1.a + mask1 > texture2.a + mask2 ? texture1.rgb : texture2.rgb;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend04.png " class="full-image" alt title style="max-width: none; width: 70%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend05.png " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>到现在，我们得到了一个不错的混合效果，并且还加入mask进行控制。<br>但是这种计算是逐像素的，即只取高度信息更高的像素，所有在边界可能出现明显锯齿：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend06.png " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>为了避免这个问题，我们可以创建一个深度变量<code>depth</code><br>若两个高度信息差在这个深度区间内，进行合理的混合：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">blend</span><span class="params">(float4 texture1, <span class="keyword">float</span> mask1, float4 texture2, <span class="keyword">float</span> mask2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> depth = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">float</span> ma = max(texture1.a + mask1, texture2.a + mask2) - depth;</span><br><span class="line">    <span class="keyword">float</span> b1 = max(texture1.a + mask1 - ma, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span> b2 = max(texture2.a + mask2 - ma, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (texture1.rgb * b1 + texture2.rgb * b2) / (b1 + b2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend07.png " class="full-image" alt title style="max-width: none; width: 70%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>上图实体部分就是这个深度区间，左边局部，和中间部分可以看到，蓝色和红色有一定混合，所以最后混合的权重会如下图所示：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend08.png " class="full-image" alt title style="max-width: none; width: 70%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>最终交接的地方，混合就会变得柔和：<br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend09.png " class="full-image" alt title style="max-width: none; width: 45%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\Graphics\terrainBlend10.png " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="UV旋转："><a href="#UV旋转：" class="headerlink" title="UV旋转："></a>UV旋转：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">float2 <span class="title">rotator</span><span class="params">(in float2 uv, in <span class="keyword">float</span> time, float2 pivot=float2(<span class="number">0.5</span>, <span class="number">0.5</span>))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">float</span> sinX = <span class="built_in">sin</span>(time);</span><br><span class="line">    <span class="keyword">float</span> cosX = <span class="built_in">cos</span>(time);</span><br><span class="line">    float2x2 rotaMatx = float2x2(cosX, -sinX, sinX, cosX);</span><br><span class="line">    uv -= pivot;</span><br><span class="line">    uv = mul(uv, rotaMatx);</span><br><span class="line">    uv += pivot;</span><br><span class="line">    <span class="keyword">return</span> uv;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Graphics/" rel="tag"># Graphics</a>
              <a href="/tags/Note/" rel="tag"># Note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Tech/HoudiniVEX/" rel="prev" title="Houdini VEX">
      <i class="fa fa-chevron-left"></i> Houdini VEX
    </a></div>
      <div class="post-nav-item">
    <a href="/Art/Unity3d/" rel="next" title="Unity3D">
      Unity3D <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Scratchapixel"><span class="nav-number">1.</span> <span class="nav-text">Scratchapixel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Geometry"><span class="nav-number">1.1.</span> <span class="nav-text">Geometry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#点，向量，法线"><span class="nav-number">1.1.1.</span> <span class="nav-text">点，向量，法线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#坐标系"><span class="nav-number">1.1.2.</span> <span class="nav-text">坐标系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点和向量的数学运算"><span class="nav-number">1.1.3.</span> <span class="nav-text">点和向量的数学运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Length"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Normalize"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Normalize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dot-Product"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Dot Product</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cross-Product"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Cross Product</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Addition-amp-Subtraction"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">Addition &amp; Subtraction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵"><span class="nav-number">1.1.4.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Square-Matrices"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Square Matrices</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GAMES101"><span class="nav-number">2.</span> <span class="nav-text">GAMES101</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#各类矩阵"><span class="nav-number">2.1.</span> <span class="nav-text">各类矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转矩阵"><span class="nav-number">2.1.1.</span> <span class="nav-text">旋转矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相机变换矩阵"><span class="nav-number">2.1.2.</span> <span class="nav-text">相机变换矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正交投影矩阵"><span class="nav-number">2.1.3.</span> <span class="nav-text">正交投影矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#透视投影"><span class="nav-number">2.1.4.</span> <span class="nav-text">透视投影</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#采样"><span class="nav-number">2.2.</span> <span class="nav-text">采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几何"><span class="nav-number">2.3.</span> <span class="nav-text">几何</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LearnOpenGL"><span class="nav-number">3.</span> <span class="nav-text">LearnOpenGL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PBR"><span class="nav-number">3.1.</span> <span class="nav-text">PBR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#微平面模型"><span class="nav-number">3.1.1.</span> <span class="nav-text">微平面模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#能量守恒"><span class="nav-number">3.1.2.</span> <span class="nav-text">能量守恒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射率方程"><span class="nav-number">3.1.3.</span> <span class="nav-text">反射率方程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRDF"><span class="nav-number">3.1.4.</span> <span class="nav-text">BRDF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正态分布函数"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">正态分布函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几何函数"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">几何函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#菲涅尔方程"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">菲涅尔方程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#灯光"><span class="nav-number">3.2.</span> <span class="nav-text">灯光</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平行光"><span class="nav-number">3.2.1.</span> <span class="nav-text">平行光</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点光源"><span class="nav-number">3.2.2.</span> <span class="nav-text">点光源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚光"><span class="nav-number">3.2.3.</span> <span class="nav-text">聚光</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#帧缓存"><span class="nav-number">3.3.</span> <span class="nav-text">帧缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纹理附件"><span class="nav-number">3.3.1.</span> <span class="nav-text">纹理附件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染缓存对象附件"><span class="nav-number">3.3.2.</span> <span class="nav-text">渲染缓存对象附件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#法线"><span class="nav-number">3.4.</span> <span class="nav-text">法线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切线空间"><span class="nav-number">3.4.1.</span> <span class="nav-text">切线空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视差贴图"><span class="nav-number">3.5.</span> <span class="nav-text">视差贴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟渲染"><span class="nav-number">3.6.</span> <span class="nav-text">延迟渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高斯模糊"><span class="nav-number">3.7.</span> <span class="nav-text">高斯模糊</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ray-Marching"><span class="nav-number">4.1.</span> <span class="nav-text">Ray Marching</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何进行检测"><span class="nav-number">4.1.1.</span> <span class="nav-text">如何进行检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何获取最小距离"><span class="nav-number">4.1.2.</span> <span class="nav-text">如何获取最小距离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#军团要塞NPR渲染"><span class="nav-number">4.2.</span> <span class="nav-text">军团要塞NPR渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EA次表面散射：快速，廉价"><span class="nav-number">4.3.</span> <span class="nav-text">EA次表面散射：快速，廉价</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">4.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#厚度图"><span class="nav-number">4.3.2.</span> <span class="nav-text">厚度图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现细节"><span class="nav-number">4.3.3.</span> <span class="nav-text">实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地面高度混合"><span class="nav-number">4.4.</span> <span class="nav-text">地面高度混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用函数"><span class="nav-number">4.5.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UV旋转："><span class="nav-number">4.5.1.</span> <span class="nav-text">UV旋转：</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">业余蚊子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanziwenm" title="GitHub → https://github.com/fanziwenm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:120416678@qq.com" title="E-Mail → mailto:120416678@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.artstation.com/van_hugh" title="Artstation → https://www.artstation.com/van_hugh" rel="noopener" target="_blank"><i class="fa fa-fw fa-artstation"></i>Artstation</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">业余蚊子</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'neutral',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
