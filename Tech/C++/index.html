<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta name="keywords" content="Notes,C++,Advance">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 笔记">
<meta property="og:url" content="http://yoursite.com/Tech/C++/index.html">
<meta property="og:site_name" content="Van">
<meta property="og:description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/Notes/C++/preprocessor.jpg">
<meta property="og:image" content="http://yoursite.com/images/Notes/C++/pure_virtual_function.jpg">
<meta property="og:updated_time" content="2021-02-17T16:10:41.273Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 笔记">
<meta name="twitter:description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta name="twitter:image" content="http://yoursite.com/images/Notes/C++/preprocessor.jpg">

<link rel="canonical" href="http://yoursite.com/Tech/C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>C++ 笔记 | Van</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d76c976ebf90b8fce3fc58985d94aa40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Van</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/fanziwenm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Tech/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="业余蚊子">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Van">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-05 18:28:49" itemprop="dateCreated datePublished" datetime="2019-05-05T18:28:49+08:00">2019-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-18 00:10:41" itemprop="dateModified" datetime="2021-02-18T00:10:41+08:00">2021-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><blockquote>
<p>Compiler & Linker Works</p>
</blockquote>
<p><strong>C++</strong>的<strong>Build</strong>可以分为4个步骤：<strong>预处理</strong>，<strong>编译</strong>，<strong>汇编</strong>，<strong>链接</strong>：</p>
<pre class="mermaid" style="text-align: center;">            graph LR
            
a>Source code] -- Compiler --> c(Object code)
a1>Source code] -- Compiler --> c1(Object code)
a2>Source code] -- Compiler --> c2(Object code)

lib((Libraries)) --- lik{Linker}
c --- lik
c1 --- lik
c2 --- lik

lik --> ex[Executable]

          </pre>
<ul>
<li><p><strong>预处理</strong>：在这期间，编译器会检查所有<strong>pre-processing</strong>语句并进行评估。常见的有：<code>include</code>,<code>define</code>,<code>if</code>和<code>ifdef</code>…</p>
</li>
<li><p><strong>编译</strong>：一般来说，每一个<code>.cpp</code>文件都会编译成一个<code>.obj</code>文件(Object code 目标代码)，这些<code>.cpp</code>文件也叫做<strong>编译单元(Translation Unity)</strong></p>
</li>
<li><p><strong>汇编</strong>：有些情况，目标代码不是直接产生，会先以<strong>汇编语言语</strong>句的形式存在，然后再经过一个独立的编译阶段。</p>
</li>
<li><p><strong>链接</strong>：经过上一步后，将所有<code>.obj</code>文件通过<strong>Linker</strong>链接成一个可执行的<code>.exe</code>文件。</p>
</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p><code>include</code>的原理非常简单，就是将包含的文件内容完完全全拷贝到当前文件。就如此简单，而且可以很好证明。</p>
<p>先再一个<code>.cpp</code>文件中写一段简单的代码：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"hello world"</span> << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>注意，上面代码末尾少了个<code>}</code>,如果编译会报错：<code>Main.cpp(3): fatal error C1075: '{': no matching token found</code></p>
<a id="more"></a>
<p>而我们接着创建一个<code>.h</code>文件，里面只写一个<code>}</code></p>
<figure class="highlight cpp"><figcaption><span>endBrace.h</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们在文件<code>Main.cpp</code>中<code>include</code>该文件：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"hello world"</span> << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"endBrace.h"</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>这样我们就会发现，编译就没有任何报错。<br>这应该就能搞懂了。其实就是简单的将头文件内容拷贝到当前文件中。</p>
<div class="note info">
            <p>我们还可以让编译器输出一个文档，来查看pre-processor的结果，<br>VS可在<strong>项目属性(Properties)</strong>中的<strong>C/C++</strong>一栏中的<strong>Preprocessor</strong>中设置<strong>Preprocess to a File</strong>为<code>yes</code></p><p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\C++\preprocessor.jpg " class="full-image" alt title style="max-width: none; width: 75%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><p>这样，编译器不会生成<code>.obj</code>文件，但是会生成一个<code>.i</code>文件。</p><p>我们可以用任意编辑器打开<code>Main.i</code>：<br>我们直接跳到最后（因为我们包含了<code>iostream</code>，所有前面会有一大堆来自<code>iostream</code>的代码）:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#line 2 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\Main.cpp"</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    std::cout << "hello world" << std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">#line 1 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\endBrace.h"</span><br><span class="line">}</span><br><span class="line">#line 9 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\Main.cpp"</span><br></pre></td></tr></tbody></table></figure><p>这就很明显了吧，我们看到<code>}</code>从<code>endBrace.h</code>插入到该文件中。</p>
          </div>
<div class="note primary">
            <p><strong>#include</strong>包括两种形式：</p><ul><li><code>#include < ></code></li><li><code>#include " "</code></li></ul><p><code>#include < ></code> 引用的是编译器的类库路径里面的头文件。<br><code>#include " "</code> 引用的是你程序目录的相对路径中的头文件。</p>
          </div>
<div class="note info">
            <p>有些C头文件被转换为C++头文件，这些文件被重新命名，去掉了扩展名h(使之成为C++风格的名称),但是在文件名称前加上前缀<code>c</code>（表示来自C语言),例如C语言的数学函数<code>#include<cmath></cmath></code></p>
          </div>
<!-- more -->
<hr>
<h3 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h3><p>编译器很相信我们，如果我们声明了一个函数。它就认为真有这个函数，即使这个函数没有函数体。<br>如果声明了一个函数，但是没有定义这个函数到底是干嘛的，编译还是会正常进行。至于这个函数是干嘛的则是由<strong>Linker</strong>去找。当然，如果它找不到，自然就会出现错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码声明了函数<code>log()</code>但是它没有定义具体内容。如果进行<strong>Compile</strong>，对单个文件进行编译结果不会有任何问题：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1>------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------</span><br><span class="line">1>Main.cpp</span><br><span class="line">========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果<strong>build</strong>整个工程,就会抛出<code>Link</code>的错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1>------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------</span><br><span class="line">1>log.cpp</span><br><span class="line">1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl log(char const *)" (?log@@YAXPBD@Z) referenced in function "int __cdecl multiplay(int,int)" (?multiplay@@YAHHH@Z)</span><br><span class="line">1>D:\C++\Projects\HelloWorld\HelloWorld\Debug\HelloWorld.exe : fatal error LNK1120: 1 unresolved externals</span><br><span class="line">1>Done building project "HelloWorld.vcxproj" -- FAILED.</span><br><span class="line">========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>错误大致分两类：</p><ul><li><p>编译错误，以<code>C</code>开头：<br><code>fatal error C1075: '{': no matching token found</code></p></li><li><p>链接错误，以<code>LNK</code>开头：<br><code>1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl log(char const *)"</code></p></li></ul>
          </div>
<p><strong>Linker</strong>最容易出现的问题还是重复声明。</p>
<p>我们先新建一个<code>log.cpp</code>文件来完善<code>log()</code>函数。然后进行<strong>Build</strong>，结果肯定没什么问题。</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果我们在<code>Main.cpp</code>中也完善了<code>log()</code>函数：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{...</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们再进行<strong>Build</strong>，结果就会抛出一个Link错误：<code>fatal error LNK1169: one or more multiply defined symbols found</code>，错误说：找到多个被定义的符号。<br>链接器不知道到底要链接到<code>log.cpp</code>里的<code>log()</code>函数还是<code>Main.cpp</code>中的。</p>
<p>这个问题不可避免，而且不好找到。</p>
<p>还有个跟典型的例子：</p>
<p>我们把函数<code>log</code>的定义放到了头文件<code>log.h</code>中：</p>
<figure class="highlight cpp"><figcaption><span>log.h</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在源文件<code>log.cpp</code>中调用一次：</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runLog</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"run in log.cpp"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同时我们在源文件<code>Main.cpp</code>中也要用到函数<code>log</code>:</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，我们只定义了一次函数<code>log</code>,但<strong>Build</strong>的结果还是：<code>fatal error LNK1169: one or more multiply defined symbols found</code>。</p>
<p>原因其实不难理解。上面提到了<strong>include</strong>的原理就是将include文件的代码原原本本的拷贝到<code>#include</code>语句的位置。所以实际的结果是：</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// original include statement</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runLog</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"run in log.cpp"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// original include statement</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样看就很明显，我们确实定义了两次<code>log()</code>函数。</p>
<p>要解决这种问题可以使用<code>static</code>或者<code>inline</code>来定义函数。<br>或者，更常用的方法就是将函数的声明放头文件<code>.h</code>中，定义放在另一个<code>.cpp</code>文件中。</p>
<hr>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><blockquote>
<p>Header Files</p>
</blockquote>
<hr>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>array</p>
</blockquote>
<p><strong>数组(array)</strong>是一种数据格式，能够存储多个同类型的值。<br>数组之所以被称为复合类型，是因为它是使用其他类型来创建的。</p>
<p>数组声明应指出一下三点：</p>
<ul>
<li>存储在每个元素中值的类型；</li>
<li>数组名；</li>
<li>数组中的元素数。</li>
</ul>
<p>例如一个月份数组：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> months[<span class="number">12</span>]; <span class="comment">// creates array of 12 short</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>不能仅仅将某种东西声明为数组，它必须是特定类型的数组：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> price[<span class="number">20</span>];</span><br></pre></td></tr></tbody></table></figure><p><code>price</code>的类型不是<strong>数组</strong>，而是<strong>float数组</strong>。这强调了<code>price</code>数组是使用<strong>float</strong>类型创建的。</p>
          </div>
<p><strong>数组的初始化规则：</strong></p>
<p>如果只对数组的一部分进行初始化，则编译器将吧其他元素设置为<code>0</code>。<br>因此，将数组中所有的元素都初始化为<code>0</code>非常简单——<span class="label info"> 只要显式地将第一个元素初始化为0</span></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> all[<span class="number">100</span>] = {<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure>
<p>如果初始化数组时的方括号<code>[]</code>为空，C++编译器将计算元素 个数。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[] = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>};</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p>通常，让编译器计算元素个数是种很糟糕的做法，因为其计数可能与你想象的不一样。<br>然而，这种方法对于将<strong>字符数组</strong>初始化为一个<strong>字符串</strong>来说比较安全</p>
          </div>
<p><strong>初始化二维数组</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxtemps[<span class="number">4</span>][<span class="number">5</span>] =    <span class="comment">// 2-D array</span></span><br><span class="line">{</span><br><span class="line">    {<span class="number">96</span>, <span class="number">100</span>, <span class="number">87</span>, <span class="number">101</span>, <span class="number">105</span>},</span><br><span class="line">    {<span class="number">96</span>, <span class="number">98</span>, <span class="number">91</span>, <span class="number">107</span>, <span class="number">104</span>},</span><br><span class="line">    {<span class="number">97</span>, <span class="number">101</span>, <span class="number">93</span>, <span class="number">108</span>, <span class="number">107</span>},</span><br><span class="line">    {<span class="number">98</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">109</span>, <span class="number">108</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>string</p>
</blockquote>
<p>字符串是存储在内存的连续字节中的一系列字符。<br><strong>C++</strong>处理字符串的方式有两种：</p>
<ul>
<li>第一种，来自<strong>C</strong>语言，通常被称为<strong>C-风格字符串(C-style string)</strong>；</li>
<li>第二种，基于<strong>String</strong>类库的方法。</li>
</ul>
<h4 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C-风格字符串"></a>C-风格字符串</h4><p><strong>C-风格字符串</strong>具有一种特殊的性质：<span class="label info">以空字符(null character)结尾</span> 空字符写做<code>\0</code>,其<strong>ASCII</strong>码为<code>0</code>。</p>
<p>例如下面两个声明：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString1[<span class="number">5</span>] = {<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>};  <span class="comment">// not a string!!!</span></span><br><span class="line"><span class="keyword">char</span> myString2[<span class="number">6</span>] = {<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>, <span class="string">'\0'</span>};    <span class="comment">// a string!</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果使用<code>cout</code>显示<code>myString1</code>这样的字符串，它除了打印出<code>hello</code>之外还会继续打印内存中随后的字节，直到出现空字符为止（我这边的结果输出结果<code>hello[I</code>）</p>
<p>在上面的例子中，初始化字符串弄得很复杂，用了大量的单引号，而且还要注意加上空字符。<br>而又种更好的初始化方法，就是使用一个<strong>双引号</strong>扩起的字符串。这种字符也称为<strong>字符串常量(string constant)</strong>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString1[<span class="number">6</span>] = <span class="string">"hello"</span>; <span class="comment">//the \0 is understood</span></span><br><span class="line"><span class="keyword">char</span> myString2[] = <span class="string">"world"</span>; <span class="comment">//let the compiler count</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>用双引号括起来的字符串隐式地包括结尾的空字符。<br>使用字符串常量初始化字符串数组时，让编译器计算元素数目更为安全。</p>
          </div>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> myString1[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> myString2[] = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="built_in">strlen</span>(myString1) << <span class="built_in">endl</span>; <span class="comment">// result: 5</span></span><br><span class="line">    myString2[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> << myString2 << <span class="built_in">endl</span>; <span class="comment">// result: wor</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="built_in">strlen</span>(myString2) << <span class="built_in">endl</span>; <span class="comment">// result: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面这段代码中，用到了函数<code>strlen()</code>。该函数只计算可见的字符，而不把空字符计算在内。<br>还有我们注意到，如果在字符串中插入一个空字符。该字符串后面部分将被忽略。</p>
<div class="note warning">
            <p><code>cin</code>使用空白来确定字符串的结束为止，所以它只能读取一个单词。<br>如果需要整行字符串则要使用<code>cin.getline()</code>或者<code>cin.get()</code></p>
          </div>
<h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>要使用<strong>string</strong>类，必须在程序中包含头文件<code>string</code>。<strong>string</strong>类位于命名空间<code>std</code>中。<br>string类定义隐藏了字符串的数组性质，<span class="label success">让你能够像处理普通变量一样处理字符串</span></p>
<p>使用string类的方式和使用字符串数组相同：</p>
<ul>
<li>可以使用C-风格字符串来初始化<strong>string</strong>对象；</li>
<li>可以使用<code>cin</code>来将键盘输入存储到<strong>string</strong>对象中；</li>
<li>可以使用<code>cout</code>来显示<strong>string</strong>对象；</li>
<li>可以使用数组表示法来访问存储在<strong>string</strong>对象中的字符。</li>
</ul>
<div class="note success">
            <p>不能将一个数组赋给另一个数组，但是可以将一个string对象赋给另一个string对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">"fanziwen"</span>;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"fanziwen"</span>;</span><br><span class="line">charr1 = charr2; <span class="comment">// INVALID</span></span><br><span class="line">str1 = str2; <span class="comment">// VALID</span></span><br></pre></td></tr></tbody></table></figure>
          </div>
<p><strong>string类</strong>简化了字符串合并操作。可以使用运算符<code>+</code>将两个string对象<strong>合并</strong>起来。还可以使用运算符<code>+=</code>将字符串<strong>附加</strong>到string对象的末尾。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"fan"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"ziwen"</span>;</span><br><span class="line"><span class="built_in">string</span> str3 = str1 + str2; <span class="comment">// result: "fanziwen"</span></span><br><span class="line">str1 += str2; <span class="comment">// result: "fanziwen"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>enum</p>
</blockquote>
<p><strong>enum</strong>是另一种创建符号常量的方式，这种方式可以代替<strong>const</strong><br>使用<strong>enum</strong>的句法和结构相似：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum {</span><br><span class="line">    red, orange, yellow, green, blue, violet, indigo, ultraviolet</span><br><span class="line">};</span><br><span class="line">spectrum band;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>对于枚举，只定义了<strong>赋值运算符</strong>，只能将定义<strong>枚举</strong>时使用的<strong>枚举量</strong>赋给这种<strong>枚举的变量</strong>：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">band = blue;        <span class="comment">// 合法</span></span><br><span class="line">++band;             <span class="comment">// 不合法</span></span><br><span class="line">color = <span class="number">3</span> + read;   <span class="comment">// 不合法</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>枚举量是<strong>整型</strong>，可被提升为<strong>int</strong>类型，但是int类型不能自动转换为<strong>枚举类型</strong>：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> color = blue;       <span class="comment">// 合法</span></span><br><span class="line">band = <span class="number">3</span>;               <span class="comment">// 不合法，int 不能转枚举类型</span></span><br><span class="line">color = <span class="number">3</span> + red;        <span class="comment">// 合法，red 被转换成整型</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote>
<p>pointer</p>
</blockquote>
<p>计算机程序在存储数据时必须跟踪的3种基本属性：</p>
<ul>
<li>信息存储在<strong>何处</strong>；</li>
<li>存储的<strong>值</strong>是多少；</li>
<li>存储的信息是什么<strong>类型</strong>。</li>
</ul>
<div class="note primary">
            <p><strong>指针</strong>是一个<strong>变量</strong>，存储的是值的<strong>地址</strong>，而不是值的本身。</p>
          </div>
<p><code>*</code>运算符被称为<strong>间接值(indirect velue)</strong>或<strong>解除引用(dereferencing)</strong>运算符，将其应用于<strong>指针</strong>，可以得到该地址<strong>储存的值</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span>* p_updates;</span><br><span class="line">    p_updates = &updates;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Values: updates = "</span> << updates;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">", *p_updates = "</span> << *p_updates << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Addresses: &updates = "</span> << &updates;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">", p_updates = "</span> << p_updates << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    *p_updates = *p_updates + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Now updates = "</span> << updates << <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Values: updates = 6, *p_updates = 6</span></span><br><span class="line"><span class="comment">// Addresses: &updates = 00AFF9C4, p_updates = 00AFF9C4</span></span><br><span class="line"><span class="comment">// Now updates = 7</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p><code>*</code>运算符两边的空格是可选的。<br>传统上，<strong>C</strong>程序员使用这样的格式:<br><code>int *ptr;</code><br>这强调<code>*ptr</code>是一个int类型的值。<br>而很多<strong>C++</strong>程序员使用这种格式：<br><code>int* ptr;</code><br>这强调的是<code>int*</code>是一种类型——指向int的指针</p>
          </div>
<div class="note warning">
            <p>但是要知道的是，下面的声明创建了一个指针<code>p1</code>和一个int变量<code>p2</code><br><code>int* p1, p2;</code><br>如果要声明两个指针，则都要加<code>*</code></p>
          </div>
<div class="note danger">
            <p><strong>指针不是整数</strong>，虽然计算机通常把地址当作整数来处理。<br>整数是可以执行加、减、乘除，但是指针描述的是位置，<span class="label danger">将两个地址相乘没有任何意义</span></p>
          </div>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p><strong>分配内存</strong></p>
<p>变量是在编译时分配的<strong>有名字的内存</strong>，而指针只是为可通过名字直接访问的内存提供了一个别名。<br><span class="label info">指针真正的用武之地在于，在运行阶段分配<b>未命名的内存</b>以存储值。</span><br><code>new</code>将找到一个长度正确的<strong>内存块</strong>，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></tbody></table></figure>
<div class="note default">
            <p><code>pn</code>指向的内存没有名称，我们说<code>pn</code>指向一个<strong>数据对象</strong>，<strong>数据对象</strong>比<strong>变量</strong>更通用，它指的是为数据项分配的内存块。<br>变量也是数据对象，但是<code>pn</code>指向的内存不是变量。</p>
          </div>
<p><strong>分配动态数组</strong></p>
<p>通常，对于大型数据（如数组、字符串和结构），应使用<code>new</code>。<br><span class="label warning">如果通过声明创建数组，则在程序被编译时，将为它分配内存空间。不管程序最终是否使用数组，它都占用了内存。</span></p>
<p>但使用<code>new</code>时，如果在运行阶段需要数组，则创建；不需要，则不创建。还可以在程序运行时选择数组的长度。<br>则被称为<strong>动态联编(dynamic binding)</strong>,而这样的数组叫<strong>动态数组(dynamic array)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// get a block of 10 ints</span></span><br></pre></td></tr></tbody></table></figure>
<p>当程序使用完<code>new</code>分配出来的内存块时，应使用<code>delete</code>释放它们。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psone;</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>方括号告诉程序，应该释放整个数组，而不仅仅是指针指向的元素。<br>如果使用<code>new</code>时，不带方括号，则<code>delete</code>时也不带方括号。</p>
          </div>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><strong>释放内存</strong></p>
<p><code>delete</code>运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效的使用内存的关键一步。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ps = <span class="keyword">new</span> <span class="keyword">int</span>;    <span class="comment">// allocate memory with new</span></span><br><span class="line">...                   <span class="comment">// use the memory</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">// free memory with delete</span></span><br></pre></td></tr></tbody></table></figure>
<span class="label info">这将释放<b>ps指向的内存</b>，但是不会删除指针<b>ps本身</b></span>
<div class="note danger">
            <p>只能用<code>delete</code>来释放<code>new</code>分配的内存。<br>对于空指针，使用<code>delete</code>是安全的。</p>
          </div>
<h4 id="new和delete总结"><a href="#new和delete总结" class="headerlink" title="new和delete总结"></a>new和delete总结</h4><ul>
<li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存。</li>
<li>不要使用<code>delete</code>释放同一个内存块两次。</li>
<li>如果使用<code>new[]</code>为数组分配内存，则应该使用<code>delete[]</code>来释放。</li>
<li>如果使用<code>new</code>为一个实体分配内存，则应该使用<code>delete</code>（没有方括号）来释放。</li>
<li>对空指针应用<code>delete</code>是安全的。</li>
</ul>
<h4 id="指针算数"><a href="#指针算数" class="headerlink" title="指针算数"></a>指针算数</h4><blockquote>
<p>pointer arithmetic</p>
</blockquote>
<span class="label primary">将整数增加1，其值增加1；但是将指针增加1，增加的量等于它指向的<b>类型字节数</b></span>
<blockquote>
<p>将指向<strong>double</strong>的指针增加1后，如果系统对<strong>double</strong>使用8个字节存储，则数组增加8。<br><strong>sort</strong>的指针增加1后，指针的值就可能增加2。</p>
</blockquote>
<div class="note primary">
            <p>C++ 将数组名解释为地址:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wages[<span class="number">3</span>] = {<span class="number">100.0</span>, <span class="number">200.0</span>, <span class="number">300.0</span>};</span><br><span class="line"><span class="keyword">double</span>* pw = wages; <span class="comment">// name of array = address</span></span><br><span class="line"><span class="comment">/* wages = &wages[0] = address of first element of array */</span></span><br></pre></td></tr></tbody></table></figure>
          </div>
<h4 id="new创建动态结构-类"><a href="#new创建动态结构-类" class="headerlink" title="new创建动态结构(类)"></a>new创建动态结构(类)</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    inflatable* ps = <span class="keyword">new</span> inflatable;    <span class="comment">// allot memory for structure</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter name of inflatalbe item: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get(ps->name, <span class="number">20</span>);              <span class="comment">// method 1 for member access</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter volume in cubic feet:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> (*ps).volume;                <span class="comment">// method 2 for member accress</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter price: $"</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> ps->price;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Name: "</span> << (*ps).name << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Volume: "</span> << ps->volume << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Price: $"</span> << ps->price << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p>创建动态结构时，不能将成员运算符<code>.</code>用于结构名，因为这种结构没有名称，只是知道它的地址。<br>C++专门为这种结构提供了一个运算符:<code>-></code>，来访问被指向结构体的成员。</p>
          </div>
<hr>
<h3 id="Vector类-动态数组"><a href="#Vector类-动态数组" class="headerlink" title="Vector类(动态数组)"></a>Vector类(动态数组)</h3><blockquote>
<p>Dynamic Arrays (std::vector)</p>
</blockquote>
<p>模板类<strong>vector</strong>是数组的替代品。<br><code>vector.push_back()</code><br><strong>vector</strong> 的<code>push_back</code>会先创建一个对象然后调用构造函数。然后每push一次。都会根据<strong>vector</strong>当前总共多少项进行拷贝（调用拷贝构造函数），也就是<strong>N+1</strong>（拷贝N次加一次创建）</p>
<p>所以如果在声明完<strong>vector</strong>后同时通过<code>vector.reserve()</code>确认列表大小，每次push都只会拷贝一次，但是还是会先创建一次对象（调用一次构造函数），也就是<strong>1+1</strong></p>
<p>最干净的方法就是用<code>emplace_back()</code>，这样就只会创建一次对象，而不会有任何拷贝的开销（前提是使用reserve，确定vector大小）</p>
<p>如果知道要存放多少对象进vector，可以先用<br>vector.reserve()声明vector大小。<br><code>vector.erase(vector.begin() + 1)</code></p>
<hr>
<h2 id="简单的文件输入-输出"><a href="#简单的文件输入-输出" class="headerlink" title="简单的文件输入/输出"></a>简单的文件输入/输出</h2><h3 id="文本I-O和文本文件"><a href="#文本I-O和文本文件" class="headerlink" title="文本I/O和文本文件"></a>文本I/O和文本文件</h3><p>使用<code>cin</code>输入时，不管目标数据类型是什么，输入一开始都是字符数据————<strong>文本数据</strong>。<br>然后<code>cin</code>对象负责将文本转换为其他类型。</p>
<p>假如我们输入:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38.5 19.2</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><strong>char类型：</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> >> a; <span class="comment">// input: 38.5 19.2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// result: 3</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里我们输入的第一个字符直接被赋给<code>a</code>,也就是<code>3</code>(字符3)</p>
<p><strong>int类型：</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> >> a; <span class="comment">// input: 38.5 19.2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// result: 38</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里的<code>cin</code>会一直读取到非数字字符，也就是<code>.</code>停止。所以最后结果为<code>38</code></p>
<p><strong>double类型：</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> >> a; <span class="comment">// input: 38.5 19.2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// result: 38.5</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里的<code>cin</code>会一直读到不属于浮点数的字符，也就是<em>空格</em>，所以结果为<code>38.5</code></p>
<p><strong>char数组：</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> >> a; <span class="comment">// input: 38.5 19.2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// result: 38.5</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里的<code>cin</code>会一直读到空白字符也就是<em>空格</em>，结果也是<code>38.5</code></p>
<p>另一种存储输入：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.getline(a, <span class="number">50</span>); <span class="comment">// input: 38.5 19.2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// result: 38.5 19.2</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这种情况下<code>cin</code>将不断读取，直到换行符（50个字符内）</p>
<h3 id="写入到文本文件中"><a href="#写入到文本文件中" class="headerlink" title="写入到文本文件中"></a>写入到文本文件中</h3><div class="note info">
            <p>这里讨论的<strong>文件I/O</strong>相当于<strong>控制台I/O</strong>,因此仅适用于文本文件。</p>
          </div>
<ul>
<li>包含头文件<code>fstream</code></li>
<li>声明一个（多个）<code>ofstream</code>变量（对象）</li>
<li>关联<code>ofstream</code>对象和文件，可以使用<code>open()</code></li>
<li>用完使用<code>close()</code>进行关闭</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><fstream></fstream></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::ofstream outFile;</span><br><span class="line"></span><br><span class="line">    outFile.open(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.getline(a, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    outFile << a;</span><br><span class="line"></span><br><span class="line">    outFile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>在程序运行之前，如果<strong>test.txt</strong>文件并不存在，方法<code>open()</code>将新建一个名为<strong>text.txt</strong>的文件。</p>
          </div>
<div class="note info">
            <p>方法<code>close()</code>不需要使用文件名作为参数,因为<code>outFile</code>已经同特定的文件关联起来了。<br>如果你忘记关闭文件，程序正常终止时将自动关闭它。 </p>
          </div>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><fstream></fstream></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::ifstream inFile;</span><br><span class="line"></span><br><span class="line">    inFile.open(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"Could not open the file!"</span> << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> line[SIZE];</span><br><span class="line">    inFile.getline(line, SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << line << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>读取文件和写入类似，不过需要一个<code>ifstream</code>对象。<br>还要添加一个方法<code>is_open()</code>来检查文件是否被打开，如果失败，用<code>std::exit(EXIT_FAILURE)</code>终止程序。</p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>要使用<strong>C++</strong>函数，必须完成如下工作：</p>
<ul>
<li>提供函数定义；</li>
<li>提供函数原型；</li>
<li>调用函数。</li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数定义分<strong>有返回值</strong>和<strong>没有返回值</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// optional</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">typeName <span class="title">functionName</span><span class="params">(parameterList)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// value is type cast to type typeName</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>函数原型是一条语句，因此必须以分号介绍。<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>然而，函数原型不需要提供变量名，有类型列表就足够了。<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><strong>为什么需要原型：</strong></p>
<ul>
<li>确保编译器<strong>正确处理函数返回值</strong>；</li>
<li>确保编译器检查使用的参数<strong>数目是否正确</strong>；</li>
<li>确保编译器检查使用的参数<strong>类型是否正确</strong>。如果不正确，则转换为正确的类型（如果可能的话）</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><blockquote>
<p>Function Pointer</p>
</blockquote>
<p><strong>函数指针</strong>，简单来说就是将函数变成一个变量。<br>目前我们使用到函数，基本都是需要的时候我们就调用它，做一些逻辑处理。<br>但是其实函数可以变为一个变量，这样我们就可以把它当成一个变量传给另一个函数。或者一些的别复杂逻辑。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << “hello world” << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> function = HelloWorld;</span><br><span class="line">    function();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>就像上面的代码，我们将<code>HelloWordl</code>函数存成一个变量（暂时不知道类型所以用<code>auto</code>修饰）。然后我们就能通过变量名调用函数。<br>这时候如果你鼠标移动到<code>function</code>上，vs会告诉你它的类型是<br><code>void (*function)()</code>，而这就是<strong>函数指针</strong></p>
<p>所以如果你想吧<code>auto</code>替换掉可以写成：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">void</span> (*function)() = HelloWorld;</span><br><span class="line">function();</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>但是这样的定义可读性很差，所以可以使用<code>typedef</code>或者<code>using</code><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*HelloWorldFunc)</span><span class="params">()</span></span>; <span class="comment">// method a</span></span><br><span class="line"><span class="keyword">using</span> HelloWorldFunc = <span class="keyword">void</span>(*)(); <span class="comment">// method b</span></span><br><span class="line"></span><br><span class="line">HelloWorldFunc function = HelloWorld;</span><br><span class="line">function();</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>如果你定义的函数有参数，例如：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloWorld</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"hello world! Value:"</span><< a <<  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> HelloWorldFunc = <span class="keyword">void</span>(*)(<span class="keyword">int</span>);  <span class="comment">// add int parm</span></span><br><span class="line">    HelloWorldFunc function = HelloWorld;</span><br><span class="line">    function(<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>函数指针的典型例子：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintValue</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"Value: "</span> << a << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForEach</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>>& values, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : values)</span><br><span class="line">        func(value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> values = { <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> };</span><br><span class="line">    ForEach(values, PrintValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>我们先创建了一个动态数组，然后需要遍历它，遍历的函数<code>ForEach</code>需要额外传入一个处理函数，<code>ForEach</code>函数的第二个参数是一个函数指针。</p>
<div class="note info">
            <p>当然，传入的第二个函数指针参数像上面的<code>PrintValue</code>那么简单，完全可以用Lambda函数代替<br><code>[](int value) { std::cout << “Value: “ << value << std::endl; }</code></p>
          </div>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><blockquote>
<p>The “this” keyword</p>
</blockquote>
<p>我们知道实例化对象，也知道那些对象有它们的方法和成员变量<br>正常情况下我们需要先实例化一个对象，才能调用它的方法和变量，而<code>this</code>就是这些实例化对象的指针<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Entity(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>->x = x;</span><br><span class="line">        <span class="comment">// (*this).x = x;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>正如上面的构造函数，我们声明了一个成员变量<code>x</code>，但是我们同时传入了一个参数<code>x</code>。这样我们无法很好的分辨这两个<code>x</code>。<br>所以可以使用<code>this->x</code>或者<code>(*this).x</code>来表示成员变量的x。当然前者更为清晰而且常用</p>
<p>再比如需当声明了一个函数需要传入一个类的指针<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(Entity* e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PrintEntity(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>当然也可能传入的是一个引用<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity& e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PrintEntity(*<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><blockquote>
<p>Virtual Functions</p>
</blockquote>
<p>我们先定义三个类，父类<strong>Entity</strong>，子类<strong>Player</strong>和<strong>Mesh</strong><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Entity(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        : m_Name(name) {}</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"[Entity]: "</span>) + m_Name; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Player(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        :Entity(name) {}</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"[Player]: "</span>) + m_Name; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mesh(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        :Entity(name) {}</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"[Mesh]: "</span>) + m_Name; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到上面三个类都有方法<code>GetName()</code><br>如果我们正常的声明这三个类，然后使用这个方法，并没有任何问题：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Entity e = Entity(<span class="string">"Entity01"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << e.GetName().c_str() << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">Player p = Player(<span class="string">"Player01"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << p.GetName().c_str() << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">Mesh m = Mesh(<span class="string">"Mesh01"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << m.GetName().c_str() << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [Entity]: Entity01</span></span><br><span class="line"><span class="comment">// [Player]: Player01</span></span><br><span class="line"><span class="comment">// [Mesh]: Mesh01</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>但是如果出现下面这种情况，就会出现问题：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Entity* ptrP = &p;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> << ptrP->GetName().c_str() << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [Entity]: Player01</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>p</code>命名是一个<strong>Player</strong>对象，结果它使用的是<strong>Entity</strong>的<code>GetName()</code>方法。</p>
<p>为了解决这个问题，就要用到<strong>虚函数(Virtual Function)</strong>让继承的子类对该函数进行<strong>重写</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Entity(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        : m_Name(name) {}</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"[Entity]: "</span>) + m_Name; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Player(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        :Entity(name) {}</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> override </span>{ <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"[Player]: "</span>) + m_Name; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>我们在<strong>Entity</strong>中的<code>GetName()</code>前面加了一个关键字<code>virtual</code>，同时在<strong>Player</strong>中的<code>GetName()</code>的定义前加了<code>override</code><br>这样一来，当该方法被调用时，它就能找到对应类的对应方法</p>
<div class="note warning">
            <p><code>override</code>可以省略，但是为了代码规范，和可读性尽量加上。<br>如果被重写的函数不是虚函数，<code>override</code>关键字也可以然函数报红。</p>
          </div>
<h3 id="纯虚函数（接口）"><a href="#纯虚函数（接口）" class="headerlink" title="纯虚函数（接口）"></a>纯虚函数（接口）</h3><p>在了解了虚函数之后。就可以理解什么是<strong>纯虚函数</strong>了。<br>虚函数是可以进行重写的函数，但是也可以不进行重写；<br>而纯虚函数，则是没有定义的，<strong>必须被重写</strong>的函数。</p>
<div class="note primary">
            <p>如果一个类有纯虚函数没被重写，那它就是一个<strong>抽象类</strong>，不能直接进行实例化</p>
          </div>
<p>例如我们把上面的<strong>Entity</strong>的<code>GetName()</code>改写成虚函数：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Entity(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>& name)</span><br><span class="line">        : m_Name(name) {}</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>将虚函数的定义改成<code>= 0</code>就变成了<strong>纯虚函数</strong>；<br>这个时候，<strong>Entity</strong>就不能直接进行实例化了：</p>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\C++\pure_virtual_function.jpg " class="full-image" alt title style="max-width: none; width: 55%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>这里的报错说明<strong>Entity</strong>是一个不被允许的<strong>抽象类(abstract class)</strong>,里面有个纯虚函数<code>GetName()</code></p>
<p>但是<strong>Player</strong>和<strong>Mesh</strong>类还是能正常工作，因为它们已经将这个虚函数进行了重写。</p>
<h3 id="操作符重写"><a href="#操作符重写" class="headerlink" title="操作符重写"></a>操作符重写</h3><blockquote>
<p>Operator Overloading</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vector2 <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2& other) <span class="keyword">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="function">Return <span class="title">Vector2</span><span class="params">(x + other.x, y + other.y)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream& <span class="keyword">operator</span><<(<span class="built_in">std</(<span></span>::ostream& stream, <span class="keyword">const</span> Vector2& other)<br><span class="line">{</span><br><span class="line">    stream <<  other.x << “, “ <<  other.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2& other) <span class="keyword">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> x == other.x && y == other.y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Vector2& other) <span class="keyword">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p><code>new</code>和<code>delete</code>也是操作符</p>
          </div>
<hr>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><blockquote>
<p>Templates</p>
</blockquote>
<p><strong>模版（Templates）</strong>可以让编译器根据你定的规则，为你编写代码。<code>template<typename t></typename></code></p>
<p>当通过模板定义的函数没有被使用到，那这个函数就根本不存在，它就只是个模板（代码有问题也能编译通过）。</p>
<p>模板不是只能使用<code>typename</code>，还可以使用<code>int</code>，例如：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">int</span> N></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> N; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>当我们声明一个<code>Array&lt5> array;</code><br>其实就是用上面的模板创建了一个类：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Array[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> <span class="number">5</span>; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>我们还能更近一步，为这个类添加<code>typename</code><br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span><<span class="keyword">typename</span> T, <span class="keyword">int</span> N></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这样我们就能通过<code>Array&ltstd::string, 50> array</code>创建一个<code>50</code>大小的<strong>string</strong>类型的数组。</p>
<hr>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><blockquote>
<p>lambda expression</p>
</blockquote>
<p>从C++11开始支持匿名函数，也成<strong>Lambda 表达式</strong>,具体形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -> return_type { function_body }</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -> <span class="keyword">int</span> { <span class="keyword">return</span> x + y; }</span><br></pre></td></tr></tbody></table></figure>
<div class="note success">
            <p>如果没有参数，圆括号<code>()</code>可以省略。<br>如果函数体只有一条<code>return</code>语句组成，或者返回类型为<code>void</code>，返回类型也可以省略。</p>
          </div>
<p>C++11也支持<strong>闭包(Closures)</strong>,闭包在方括号<code>[ ]</code>中定义。这种机制允许这些变量被读取或者引用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//no variables defined. Attempting to use any external variables in the lambda is an error.</span></span><br><span class="line">[x, &y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&]       <span class="comment">//any external variable is implicitly captured by reference if used</span></span><br><span class="line">[=]       <span class="comment">//any external variable is implicitly captured by value if used</span></span><br><span class="line">[&, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< algorithm ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< array ></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> myArr[<span class="number">5</span>] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    <span class="built_in">array</span><<span class="keyword">int</span>, 5> newArr;</span><br><span class="line">    transform(</span><br><span class="line">        begin(myArr), end(myArr), newArr.begin(),</span><br><span class="line">        [](<span class="keyword">int</span> a){ <span class="keyword">return</span> a*<span class="number">2</span>;}</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: newArr){</span><br><span class="line">        <span class="built_in">cout</span> << i << <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h3><blockquote>
<p>auto key</p>
</blockquote>
<p><code>auto</code>的应用有利有弊。合理的使用<code>auto</code>可以使<strong>API</strong>产生变化时不需要修改代码。但是也可能出现隐性的类型错误，难以进行<strong>debug</strong></p>
<p>不过在有些情况下还是很适合使用auto，比如：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span><<span class="built_in">std</span>::<span class="built_in">string</span>>::iterator it = strings.begin();</span><br><span class="line">    it != <span class="built_in">string</span>.end(); it++)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">std</span>::count << *it << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用 auto 关键字</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> it = strings.begin(); it != <span class="built_in">string</span>.end(); it++)</span><br><span class="line">{</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<div class="note warning">
            <p>想这种繁琐的类型声明就适合用<code>auto</code>增强可读性。<br>反而像<code>int，char</code>这种简单的类型，如果你还要用<code>auto</code>，则降低了代码的可读性</p>
          </div>
<p>最常用到<code>auto</code>的原因还是，在代码情况复杂的时候，你不确定返回值类型。<br>当然你也可以去追溯源码，确认数据类型，但是有时候情况远比你想的复杂。所以这种情况反而直接用<code>auto</code>省时省力。</p>
<h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><blockquote>
<p>Copy Constructors</p>
</blockquote>
<p>最常见的就是我们的赋值，当我们声明一个整型<code>a</code>，然后<code>a</code>的值又赋值给<code>b</code>这就是一个<strong>拷贝（copy）</strong>。<code>a</code>和<code>b</code>有两个不同的内存。<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">20</span>;  <span class="comment">// b的值的修改不影响a</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>另一种情况则是我们声明了一个指针<code>a</code>，然后这个<code>a</code>又赋值给另一个指针<code>b</code>，当我们修改指针<code>b</code>里的内容，自然也修改了<code>a</code>指向的内容。<br>（确实跟引用有点像，但是一个引用不能赋值给另一个引用）<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span>* b = a;</span><br><span class="line">*b = <span class="number">20</span>;  <span class="comment">// 同时修改 a b 里的</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>但是当一个类里有一个指针。<br>当它实例化创建的<code>a</code>，然后又将它赋值给<code>b</code>。<br>这样会存在一个问题，就是当实例<code>a</code>释放了这个指针，那<code>b</code>里的相同指针无法再次释放。程序就会奔溃。<br>同样，如果你用这个指针进行数据的修改，也会同时影响<code>a</code>, <code>b</code>。<br>面对这种问题，我们需要自定义一个类的拷贝<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity(<span class="keyword">const</span> Entity& other)</span><br><span class="line">    :m_Size(other.m_Size)</span><br><span class="line">{</span><br><span class="line">    m_Buffer = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 或者简单粗暴，不允许拷贝</span></span><br><span class="line">Entity(<span class="keyword">const</span> Entity& other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><blockquote>
<p>macro</p>
</blockquote>
<p>在预处理（Preprocess），纯文字的替换</p>
<p><code>#define debug(...) printf(__VA_ARGS__)</code></p>
<ul>
<li><code>#</code>   字符串化操作符</li>
<li><code>##</code>  符号连接操作符</li>
<li><code>\</code> 行继续符<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_CLASS_TYPE(type) static  EventType GetStaticType() { return EventType::##type; }\</span></span><br><span class="line">                                <span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="keyword">const</span> override </span>{ <span class="keyword">return</span> GetStaticType(); }\</span><br><span class="line">                                <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span> override </span>{ <span class="keyword">return</span> #type; }</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><figure class="highlight cpp"><figcaption><span>unique_ptr</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltmemory.h></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Entity()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Created Entity!"</span> << <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    ~Entity()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Destroyed Entity~"</span> << <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Hello World!"</span> << <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">unique_ptr</span>&ltEntity> entity = make_unique<entity>();</entity></span><br><span class="line">        entity->Print();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><figcaption><span>shared_ptr</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&ltEntity> e0;</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">shared_ptr</span>&ltEntity> entity = make_shared<entity>();</entity></span><br><span class="line">    e0 = entity;</span><br><span class="line">    e0->Print();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>两种智能指针都有额外开销，在不是很清楚何处释放内存的时候使用。<br>优先使用<code>unique_ptr</code>。</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><blockquote>
<p>发出一个DOS命令</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * command)</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a>b?a:b;</span><br></pre></td></tr></tbody></table></figure>
<p>等价于<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a>b){</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><ul>
<li><strong>自动存储</strong><ul>
<li>函数内部定义的常规变量使用的<strong>自动存储空间</strong>，也被称为<strong>自动变量(Automatic Variable)</strong>，意味着它们所在的函数被调用时自动产生，函数结束时自动消亡。</li>
</ul>
</li>
<li><strong>静态存储</strong><ul>
<li>静态存储是<strong>整个程序执行期间</strong>都存在的存储方式。</li>
<li>使用静态变量的两种方式：<ol>
<li>在函数外面定义它</li>
<li>声明变量时使用关键字<code>static</code></li>
</ol>
</li>
</ul>
</li>
<li><strong>动态存储</strong><ul>
<li><code>new</code>和<code>delete</code>运算符提供了一个更灵活的方法管理<strong>内存池</strong>。</li>
<li>在C++中称为<strong>自由存储空间(free store)</strong>或<strong>堆(heap)</strong>。</li>
<li>使用<code>new</code>和<code>delete</code>让程序员对内存有更大的控制权，但是内存管理也更复杂。</li>
</ul>
</li>
</ul>
<h3 id="与C的差异"><a href="#与C的差异" class="headerlink" title="与C的差异"></a>与C的差异</h3><p>输入/输出的风格差异</p>
<p><strong>scanf/printf(C):</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a; <span class="keyword">long</span> b; <span class="keyword">char</span> c; <span class="keyword">float</span> d; <span class="keyword">double</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%i %li %c %f %lf"</span>,&a,&b,&c,&d,&e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%i\n%li\n%c\n%.03f\n%.09lf\n"</span>,a,b,c,d,e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>cin/cout(C++):</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a; <span class="keyword">long</span> b; <span class="keyword">char</span> c; <span class="keyword">float</span> d; <span class="keyword">double</span> e;</span><br><span class="line">    <span class="built_in">cin</span> >> a >> b >> c >> d >>e;</span><br><span class="line">    <span class="built_in">cout</span> << a << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << b << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << c << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> << fixed << d << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> << fixed << e << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Notes/" rel="tag"># Notes</a>
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Advance/" rel="tag"># Advance</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Tech/Github/" rel="prev" title="Git使用教程">
      <i class="fa fa-chevron-left"></i> Git使用教程
    </a></div>
      <div class="post-nav-item">
    <a href="/Tech/NextMarkdown/" rel="next" title="Next主题下Markdown语法">
      Next主题下Markdown语法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译和链接"><span class="nav-number">1.</span> <span class="nav-text">编译和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#include"><span class="nav-number">1.1.</span> <span class="nav-text">include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linker"><span class="nav-number">1.2.</span> <span class="nav-text">Linker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#头文件"><span class="nav-number">2.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合类型"><span class="nav-number">3.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">3.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-风格字符串"><span class="nav-number">3.2.1.</span> <span class="nav-text">C-风格字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String类"><span class="nav-number">3.2.2.</span> <span class="nav-text">String类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">3.3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">3.4.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new"><span class="nav-number">3.4.1.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-number">3.4.2.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new和delete总结"><span class="nav-number">3.4.3.</span> <span class="nav-text">new和delete总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针算数"><span class="nav-number">3.4.4.</span> <span class="nav-text">指针算数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new创建动态结构-类"><span class="nav-number">3.4.5.</span> <span class="nav-text">new创建动态结构(类)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector类-动态数组"><span class="nav-number">3.5.</span> <span class="nav-text">Vector类(动态数组)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的文件输入-输出"><span class="nav-number">4.</span> <span class="nav-text">简单的文件输入/输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文本I-O和文本文件"><span class="nav-number">4.1.</span> <span class="nav-text">文本I/O和文本文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入到文本文件中"><span class="nav-number">4.2.</span> <span class="nav-text">写入到文本文件中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取文件"><span class="nav-number">4.3.</span> <span class="nav-text">读取文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数定义"><span class="nav-number">5.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数原型"><span class="nav-number">5.2.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数指针"><span class="nav-number">5.3.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">6.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this关键字"><span class="nav-number">6.1.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数"><span class="nav-number">6.2.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数（接口）"><span class="nav-number">6.3.</span> <span class="nav-text">纯虚函数（接口）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符重写"><span class="nav-number">6.4.</span> <span class="nav-text">操作符重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板"><span class="nav-number">7.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数"><span class="nav-number">8.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tips"><span class="nav-number">9.</span> <span class="nav-text">Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-关键字"><span class="nav-number">9.1.</span> <span class="nav-text">auto 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝构造"><span class="nav-number">9.2.</span> <span class="nav-text">拷贝构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏"><span class="nav-number">9.3.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">9.4.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System"><span class="nav-number">9.5.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元运算符"><span class="nav-number">9.6.</span> <span class="nav-text">三元运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">10.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动存储、静态存储和动态存储"><span class="nav-number">10.1.</span> <span class="nav-text">自动存储、静态存储和动态存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与C的差异"><span class="nav-number">10.2.</span> <span class="nav-text">与C的差异</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">业余蚊子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanziwenm" title="GitHub → https://github.com/fanziwenm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:120416678@qq.com" title="E-Mail → mailto:120416678@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.artstation.com/van_hugh" title="Artstation → https://www.artstation.com/van_hugh" rel="noopener" target="_blank"><i class="fa fa-fw fa-artstation"></i>Artstation</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">业余蚊子</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'neutral',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
