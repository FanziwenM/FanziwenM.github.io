<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta name="keywords" content="Notes,C++,Advance">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 笔记">
<meta property="og:url" content="http://yoursite.com/Tech/C++/index.html">
<meta property="og:site_name" content="Van">
<meta property="og:description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/Notes/C++/preprocessor.jpg">
<meta property="og:updated_time" content="2020-11-22T08:11:09.645Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 笔记">
<meta name="twitter:description" content="编译和链接 Compiler &amp; Linker Works  C++的Build可以分为4个步骤：预处理，编译，汇编，链接：             graph LR              a&amp;gt;Source code] -- Compiler --&amp;gt; c(Object code) a1&amp;gt;Source code] -- Compiler --&amp;gt; c1(Object code) a2&amp;gt;Source">
<meta name="twitter:image" content="http://yoursite.com/images/Notes/C++/preprocessor.jpg">

<link rel="canonical" href="http://yoursite.com/Tech/C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>C++ 笔记 | Van</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d76c976ebf90b8fce3fc58985d94aa40";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Van</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/fanziwenm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Tech/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="业余蚊子">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Van">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-05 18:28:49" itemprop="dateCreated datePublished" datetime="2019-05-05T18:28:49+08:00">2019-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 16:11:09" itemprop="dateModified" datetime="2020-11-22T16:11:09+08:00">2020-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><blockquote>
<p>Compiler & Linker Works</p>
</blockquote>
<p><strong>C++</strong>的<strong>Build</strong>可以分为4个步骤：<strong>预处理</strong>，<strong>编译</strong>，<strong>汇编</strong>，<strong>链接</strong>：</p>
<pre class="mermaid" style="text-align: center;">            graph LR
            
a>Source code] -- Compiler --> c(Object code)
a1>Source code] -- Compiler --> c1(Object code)
a2>Source code] -- Compiler --> c2(Object code)

lib((Libraries)) --- lik{Linker}
c --- lik
c1 --- lik
c2 --- lik

lik --> ex[Executable]

          </pre>
<ul>
<li><p><strong>预处理</strong>：在这期间，编译器会检查所有<strong>pre-processing</strong>语句并进行评估。常见的有：<code>include</code>,<code>define</code>,<code>if</code>和<code>ifdef</code>…</p>
</li>
<li><p><strong>编译</strong>：一般来说，每一个<code>.cpp</code>文件都会编译成一个<code>.obj</code>文件(Object code 目标代码)，这些<code>.cpp</code>文件也叫做<strong>编译单元(Translation Unity)</strong></p>
</li>
<li><p><strong>汇编</strong>：有些情况，目标代码不是直接产生，会先以<strong>汇编语言语</strong>句的形式存在，然后再经过一个独立的编译阶段。</p>
</li>
<li><p><strong>链接</strong>：经过上一步后，将所有<code>.obj</code>文件通过<strong>Linker</strong>链接成一个可执行的<code>.exe</code>文件。</p>
</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p><code>include</code>的原理非常简单，就是将包含的文件内容完完全全拷贝到当前文件。就如此简单，而且可以很好证明。</p>
<p>先再一个<code>.cpp</code>文件中写一段简单的代码：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"hello world"</span> << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>注意，上面代码末尾少了个<code>}</code>,如果编译会报错：<code>Main.cpp(3): fatal error C1075: '{': no matching token found</code></p>
<a id="more"></a>
<p>而我们接着创建一个<code>.h</code>文件，里面只写一个<code>}</code></p>
<figure class="highlight cpp"><figcaption><span>endBrace.h</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们在文件<code>Main.cpp</code>中<code>include</code>该文件：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << <span class="string">"hello world"</span> << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"endBrace.h"</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>这样我们就会发现，编译就没有任何报错。<br>这应该就能搞懂了。其实就是简单的将头文件内容拷贝到当前文件中。</p>
<div class="note info">
            <p>我们还可以让编译器输出一个文档，来查看pre-processor的结果，<br>VS可在<strong>项目属性(Properties)</strong>中的<strong>C/C++</strong>一栏中的<strong>Preprocessor</strong>中设置<strong>Preprocess to a File</strong>为<code>yes</code></p><p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="\images\Notes\C++\preprocessor.jpg " class="full-image" alt title style="max-width: none; width: 75%;"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><p>这样，编译器不会生成<code>.obj</code>文件，但是会生成一个<code>.i</code>文件。</p><p>我们可以用任意编辑器打开<code>Main.i</code>：<br>我们直接跳到最后（因为我们包含了<code>iostream</code>，所有前面会有一大堆来自<code>iostream</code>的代码）:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#line 2 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\Main.cpp"</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    std::cout << "hello world" << std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">#line 1 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\endBrace.h"</span><br><span class="line">}</span><br><span class="line">#line 9 "D:\\C++\\Projects\\HelloWorld\\HelloWorld\\HelloWorld\\Main.cpp"</span><br></pre></td></tr></tbody></table></figure><p>这就很明显了吧，我们看到<code>}</code>从<code>endBrace.h</code>插入到该文件中。</p>
          </div>
<div class="note primary">
            <p><strong>#include</strong>包括两种形式：</p><ul><li><code>#include < ></code></li><li><code>#include " "</code></li></ul><p><code>#include < ></code> 引用的是编译器的类库路径里面的头文件。<br><code>#include " "</code> 引用的是你程序目录的相对路径中的头文件。</p>
          </div>
<div class="note info">
            <p>有些C头文件被转换为C++头文件，这些文件被重新命名，去掉了扩展名h(使之成为C++风格的名称),但是在文件名称前加上前缀<code>c</code>（表示来自C语言),例如C语言的数学函数<code>#include<cmath></cmath></code></p>
          </div>
<!-- more -->
<hr>
<h3 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h3><p>编译器很相信我们，如果我们声明了一个函数。它就认为真有这个函数，即使这个函数没有函数体。<br>如果声明了一个函数，但是没有定义这个函数到底是干嘛的，编译还是会正常进行。至于这个函数是干嘛的则是由<strong>Linker</strong>去找。当然，如果它找不到，自然就会出现错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码声明了函数<code>log()</code>但是它没有定义具体内容。如果进行<strong>Compile</strong>，对单个文件进行编译结果不会有任何问题：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1>------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------</span><br><span class="line">1>Main.cpp</span><br><span class="line">========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果<strong>build</strong>整个工程,就会抛出<code>Link</code>的错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1>------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------</span><br><span class="line">1>log.cpp</span><br><span class="line">1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl log(char const *)" (?log@@YAXPBD@Z) referenced in function "int __cdecl multiplay(int,int)" (?multiplay@@YAHHH@Z)</span><br><span class="line">1>D:\C++\Projects\HelloWorld\HelloWorld\Debug\HelloWorld.exe : fatal error LNK1120: 1 unresolved externals</span><br><span class="line">1>Done building project "HelloWorld.vcxproj" -- FAILED.</span><br><span class="line">========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========</span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>错误大致分两类：</p><ul><li><p>编译错误，以<code>C</code>开头：<br><code>fatal error C1075: '{': no matching token found</code></p></li><li><p>链接错误，以<code>LNK</code>开头：<br><code>1>Main.obj : error LNK2019: unresolved external symbol "void __cdecl log(char const *)"</code></p></li></ul>
          </div>
<p><strong>Linker</strong>最容易出现的问题还是重复声明。</p>
<p>我们先新建一个<code>log.cpp</code>文件来完善<code>log()</code>函数。然后进行<strong>Build</strong>，结果肯定没什么问题。</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果我们在<code>Main.cpp</code>中也完善了<code>log()</code>函数：</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{...</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们再进行<strong>Build</strong>，结果就会抛出一个Link错误：<code>fatal error LNK1169: one or more multiply defined symbols found</code>，错误说：找到多个被定义的符号。<br>链接器不知道到底要链接到<code>log.cpp</code>里的<code>log()</code>函数还是<code>Main.cpp</code>中的。</p>
<p>这个问题不可避免，而且不好找到。</p>
<p>还有个跟典型的例子：</p>
<p>我们把函数<code>log</code>的定义放到了头文件<code>log.h</code>中：</p>
<figure class="highlight cpp"><figcaption><span>log.h</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在源文件<code>log.cpp</code>中调用一次：</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runLog</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"run in log.cpp"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同时我们在源文件<code>Main.cpp</code>中也要用到函数<code>log</code>:</p>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，我们只定义了一次函数<code>log</code>,但<strong>Build</strong>的结果还是：<code>fatal error LNK1169: one or more multiply defined symbols found</code>。</p>
<p>原因其实不难理解。上面提到了<strong>include</strong>的原理就是将include文件的代码原原本本的拷贝到<code>#include</code>语句的位置。所以实际的结果是：</p>
<figure class="highlight cpp"><figcaption><span>log.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &ltiostream&gt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// original include statement</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runLog</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"run in log.cpp"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><figcaption><span>Main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << message << <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// original include statement</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplay</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"Multiplay"</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> << multiplay(<span class="number">2</span>, <span class="number">5</span>) << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样看就很明显，我们确实定义了两次<code>log()</code>函数。</p>
<p>要解决这种问题可以使用<code>static</code>或者<code>inline</code>来定义函数。<br>或者，更常用的方法就是将函数的声明放头文件<code>.h</code>中，定义放在另一个<code>.cpp</code>文件中。</p>
<hr>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><blockquote>
<p>Header Files</p>
</blockquote>
<hr>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>array</p>
</blockquote>
<p><strong>数组(array)</strong>是一种数据格式，能够存储多个同类型的值。<br>数组之所以被称为复合类型，是因为它是使用其他类型来创建的。</p>
<p>数组声明应指出一下三点：</p>
<ul>
<li>存储在每个元素中值的类型；</li>
<li>数组名；</li>
<li>数组中的元素数。</li>
</ul>
<p>例如一个月份数组：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> months[<span class="number">12</span>]; <span class="comment">// creates array of 12 short</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>不能仅仅将某种东西声明为数组，它必须是特定类型的数组：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> price[<span class="number">20</span>];</span><br></pre></td></tr></tbody></table></figure><p><code>price</code>的类型不是<strong>数组</strong>，而是<strong>float数组</strong>。这强调了<code>price</code>数组是使用<strong>float</strong>类型创建的。</p>
          </div>
<p><strong>数组的初始化规则：</strong></p>
<p>如果只对数组的一部分进行初始化，则编译器将吧其他元素设置为<code>0</code>。<br>因此，将数组中所有的元素都初始化为<code>0</code>非常简单——<span class="label info"> 只要显式地将第一个元素初始化为0</span></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> all[<span class="number">100</span>] = {<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure>
<p>如果初始化数组时的方括号<code>[]</code>为空，C++编译器将计算元素 个数。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[] = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>};</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p>通常，让编译器计算元素个数是种很糟糕的做法，因为其计数可能与你想象的不一样。<br>然而，这种方法对于将<strong>字符数组</strong>初始化为一个<strong>字符串</strong>来说比较安全</p>
          </div>
<p><strong>初始化二维数组</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxtemps[<span class="number">4</span>][<span class="number">5</span>] =    <span class="comment">// 2-D array</span></span><br><span class="line">{</span><br><span class="line">    {<span class="number">96</span>, <span class="number">100</span>, <span class="number">87</span>, <span class="number">101</span>, <span class="number">105</span>},</span><br><span class="line">    {<span class="number">96</span>, <span class="number">98</span>, <span class="number">91</span>, <span class="number">107</span>, <span class="number">104</span>},</span><br><span class="line">    {<span class="number">97</span>, <span class="number">101</span>, <span class="number">93</span>, <span class="number">108</span>, <span class="number">107</span>},</span><br><span class="line">    {<span class="number">98</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">109</span>, <span class="number">108</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>string</p>
</blockquote>
<p>字符串是存储在内存的连续字节中的一系列字符。<br><strong>C++</strong>处理字符串的方式有两种：</p>
<ul>
<li>第一种，来自<strong>C</strong>语言，通常被称为<strong>C-风格字符串(C-style string)</strong>；</li>
<li>第二种，基于<strong>String</strong>类库的方法。</li>
</ul>
<h4 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C-风格字符串"></a>C-风格字符串</h4><p><strong>C-风格字符串</strong>具有一种特殊的性质：<span class="label info">以空字符(null character)结尾</span> 空字符写做<code>\0</code>,其<strong>ASCII</strong>码为<code>0</code>。</p>
<p>例如下面两个声明：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString1[<span class="number">5</span>] = {<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>};  <span class="comment">// not a string!!!</span></span><br><span class="line"><span class="keyword">char</span> myString2[<span class="number">6</span>] = {<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>, <span class="string">'\0'</span>};    <span class="comment">// a string!</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果使用<code>cout</code>显示<code>myString1</code>这样的字符串，它除了打印出<code>hello</code>之外还会继续打印内存中随后的字节，直到出现空字符为止（我这边的结果输出结果<code>hello[I</code>）</p>
<p>在上面的例子中，初始化字符串弄得很复杂，用了大量的单引号，而且还要注意加上空字符。<br>而又种更好的初始化方法，就是使用一个<strong>双引号</strong>扩起的字符串。这种字符也称为<strong>字符串常量(string constant)</strong>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> myString1[<span class="number">6</span>] = <span class="string">"hello"</span>; <span class="comment">//the \0 is understood</span></span><br><span class="line"><span class="keyword">char</span> myString2[] = <span class="string">"world"</span>; <span class="comment">//let the compiler count</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note primary">
            <p>用双引号括起来的字符串隐式地包括结尾的空字符。<br>使用字符串常量初始化字符串数组时，让编译器计算元素数目更为安全。</p>
          </div>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> myString1[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> myString2[] = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="built_in">strlen</span>(myString1) << <span class="built_in">endl</span>; <span class="comment">// result: 5</span></span><br><span class="line">    myString2[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> << myString2 << <span class="built_in">endl</span>; <span class="comment">// result: wor</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="built_in">strlen</span>(myString2) << <span class="built_in">endl</span>; <span class="comment">// result: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面这段代码中，用到了函数<code>strlen()</code>。该函数只计算可见的字符，而不把空字符计算在内。<br>还有我们注意到，如果在字符串中插入一个空字符。该字符串后面部分将被忽略。</p>
<div class="note warning">
            <p><code>cin</code>使用空白来确定字符串的结束为止，所以它只能读取一个单词。<br>如果需要整行字符串则要使用<code>cin.getline()</code>或者<code>cin.get()</code></p>
          </div>
<h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>要使用<strong>string</strong>类，必须在程序中包含头文件<code>string</code>。<strong>string</strong>类位于命名空间<code>std</code>中。<br>string类定义隐藏了字符串的数组性质，<span class="label success">让你能够像处理普通变量一样处理字符串</span></p>
<p>使用string类的方式和使用字符串数组相同：</p>
<ul>
<li>可以使用C-风格字符串来初始化<strong>string</strong>对象；</li>
<li>可以使用<code>cin</code>来将键盘输入存储到<strong>string</strong>对象中；</li>
<li>可以使用<code>cout</code>来显示<strong>string</strong>对象；</li>
<li>可以使用数组表示法来访问存储在<strong>string</strong>对象中的字符。</li>
</ul>
<div class="note success">
            <p>不能将一个数组赋给另一个数组，但是可以将一个string对象赋给另一个string对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">"fanziwen"</span>;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"fanziwen"</span>;</span><br><span class="line">charr1 = charr2; <span class="comment">// INVALID</span></span><br><span class="line">str1 = str2; <span class="comment">// VALID</span></span><br></pre></td></tr></tbody></table></figure>
          </div>
<p><strong>string类</strong>简化了字符串合并操作。可以使用运算符<code>+</code>将两个string对象<strong>合并</strong>起来。还可以使用运算符<code>+=</code>将字符串<strong>附加</strong>到string对象的末尾。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"fan"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"ziwen"</span>;</span><br><span class="line"><span class="built_in">string</span> str3 = str1 + str2; <span class="comment">// result: "fanziwen"</span></span><br><span class="line">str1 += str2; <span class="comment">// result: "fanziwen"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>enum</p>
</blockquote>
<p><strong>enum</strong>是另一种创建符号常量的方式，这种方式可以代替<strong>const</strong><br>使用<strong>enum</strong>的句法和结构相似：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum {</span><br><span class="line">    red, orange, yellow, green, blue, violet, indigo, ultraviolet</span><br><span class="line">};</span><br><span class="line">spectrum band;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>对于枚举，只定义了<strong>赋值运算符</strong>，只能将定义<strong>枚举</strong>时使用的<strong>枚举量</strong>赋给这种<strong>枚举的变量</strong>：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">band = blue;        <span class="comment">// 合法</span></span><br><span class="line">++band;             <span class="comment">// 不合法</span></span><br><span class="line">color = <span class="number">3</span> + read;   <span class="comment">// 不合法</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>枚举量是<strong>整型</strong>，可被提升为<strong>int</strong>类型，但是int类型不能自动转换为<strong>枚举类型</strong>：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> color = blue;       <span class="comment">// 合法</span></span><br><span class="line">band = <span class="number">3</span>;               <span class="comment">// 不合法，int 不能转枚举类型</span></span><br><span class="line">color = <span class="number">3</span> + red;        <span class="comment">// 合法，red 被转换成整型</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote>
<p>pointer</p>
</blockquote>
<p>计算机程序在存储数据时必须跟踪的3种基本属性：</p>
<ul>
<li>信息存储在<strong>何处</strong>；</li>
<li>存储的<strong>值</strong>是多少；</li>
<li>存储的信息是什么<strong>类型</strong>。</li>
</ul>
<div class="note primary">
            <p><strong>指针</strong>是一个<strong>变量</strong>，存储的是值的<strong>地址</strong>，而不是值的本身。</p>
          </div>
<p><code>*</code>运算符被称为<strong>间接值(indirect velue)</strong>或<strong>解除引用(dereferencing)</strong>运算符，将其应用于<strong>指针</strong>，可以得到该地址<strong>储存的值</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span>* p_updates;</span><br><span class="line">	p_updates = &updates;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"Values: updates = "</span> << updates;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">", *p_updates = "</span> << *p_updates << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"Addresses: &updates = "</span> << &updates;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">", p_updates = "</span> << p_updates << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	*p_updates = *p_updates + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"Now updates = "</span> << updates << <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Values: updates = 6, *p_updates = 6</span></span><br><span class="line"><span class="comment">// Addresses: &updates = 00AFF9C4, p_updates = 00AFF9C4</span></span><br><span class="line"><span class="comment">// Now updates = 7</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p><code>*</code>运算符两边的空格是可选的。<br>传统上，<strong>C</strong>程序员使用这样的格式:<br><code>int *ptr;</code><br>这强调<code>*ptr</code>是一个int类型的值。<br>而很多<strong>C++</strong>程序员使用这种格式：<br><code>int* ptr;</code><br>这强调的是<code>int*</code>是一种类型——指向int的指针</p>
          </div>
<div class="note warning">
            <p>但是要知道的是，下面的声明创建了一个指针<code>p1</code>和一个int变量<code>p2</code><br><code>int* p1, p2;</code><br>如果要声明两个指针，则都要加<code>*</code></p>
          </div>
<div class="note danger">
            <p><strong>指针不是整数</strong>，虽然计算机通常把地址当作整数来处理。<br>整数是可以执行加、减、乘除，但是指针描述的是位置，<span class="label danger">将两个地址相乘没有任何意义</span></p>
          </div>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p><strong>分配内存</strong></p>
<p>变量是在编译时分配的<strong>有名字的内存</strong>，而指针只是为可通过名字直接访问的内存提供了一个别名。<br><span class="label info">指针真正的用武之地在于，在运行阶段分配<b>未命名的内存</b>以存储值。</span><br><code>new</code>将找到一个长度正确的<strong>内存块</strong>，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></tbody></table></figure>
<div class="note default">
            <p><code>pn</code>指向的内存没有名称，我们说<code>pn</code>指向一个<strong>数据对象</strong>，<strong>数据对象</strong>比<strong>变量</strong>更通用，它指的是为数据项分配的内存块。<br>变量也是数据对象，但是<code>pn</code>指向的内存不是变量。</p>
          </div>
<p><strong>分配动态数组</strong></p>
<p>通常，对于大型数据（如数组、字符串和结构），应使用<code>new</code>。<br><span class="label warning">如果通过声明创建数组，则在程序被编译时，将为它分配内存空间。不管程序最终是否使用数组，它都占用了内存。</span></p>
<p>但使用<code>new</code>时，如果在运行阶段需要数组，则创建；不需要，则不创建。还可以在程序运行时选择数组的长度。<br>则被称为<strong>动态联编(dynamic binding)</strong>,而这样的数组叫<strong>动态数组(dynamic array)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// get a block of 10 ints</span></span><br></pre></td></tr></tbody></table></figure>
<p>当程序使用完<code>new</code>分配出来的内存块时，应使用<code>delete</code>释放它们。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psone;</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning">
            <p>方括号告诉程序，应该释放整个数组，而不仅仅是指针指向的元素。<br>如果使用<code>new</code>时，不带方括号，则<code>delete</code>时也不带方括号。</p>
          </div>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><strong>释放内存</strong></p>
<p><code>delete</code>运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效的使用内存的关键一步。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ps = <span class="keyword">new</span> <span class="keyword">int</span>;    <span class="comment">// allocate memory with new</span></span><br><span class="line">...                   <span class="comment">// use the memory</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">// free memory with delete</span></span><br></pre></td></tr></tbody></table></figure>
<span class="label info">这将释放<b>ps指向的内存</b>，但是不会删除指针<b>ps本身</b></span>
<div class="note danger">
            <p>只能用<code>delete</code>来释放<code>new</code>分配的内存。<br>对于空指针，使用<code>delete</code>是安全的。</p>
          </div>
<h4 id="new和delete总结"><a href="#new和delete总结" class="headerlink" title="new和delete总结"></a>new和delete总结</h4><ul>
<li>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存。</li>
<li>不要使用<code>delete</code>释放同一个内存块两次。</li>
<li>如果使用<code>new[]</code>为数组分配内存，则应该使用<code>delete[]</code>来释放。</li>
<li>如果使用<code>new</code>为一个实体分配内存，则应该使用<code>delete</code>（没有方括号）来释放。</li>
<li>对空指针应用<code>delete</code>是安全的。</li>
</ul>
<h4 id="指针算数"><a href="#指针算数" class="headerlink" title="指针算数"></a>指针算数</h4><blockquote>
<p>pointer arithmetic</p>
</blockquote>
<span class="label primary">将整数增加1，其值增加1；但是将指针增加1，增加的量等于它指向的<b>类型字节数</b></span>
<blockquote>
<p>将指向<strong>double</strong>的指针增加1后，如果系统对<strong>double</strong>使用8个字节存储，则数组增加8。<br><strong>sort</strong>的指针增加1后，指针的值就可能增加2。</p>
</blockquote>
<div class="note primary">
            <p>C++ 将数组名解释为地址:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> wages[<span class="number">3</span>] = {<span class="number">100.0</span>, <span class="number">200.0</span>, <span class="number">300.0</span>};</span><br><span class="line"><span class="keyword">double</span>* pw = wages; <span class="comment">// name of array = address</span></span><br><span class="line"><span class="comment">/* wages = &wages[0] = address of first element of array */</span></span><br></pre></td></tr></tbody></table></figure>
          </div>
<h4 id="new创建动态结构-类"><a href="#new创建动态结构-类" class="headerlink" title="new创建动态结构(类)"></a>new创建动态结构(类)</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    inflatable* ps = <span class="keyword">new</span> inflatable;    <span class="comment">// allot memory for structure</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter name of inflatalbe item: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get(ps->name, <span class="number">20</span>);              <span class="comment">// method 1 for member access</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter volume in cubic feet:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> (*ps).volume;                <span class="comment">// method 2 for member accress</span></span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Enter price: $"</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> ps->price;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Name: "</span> << (*ps).name << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Volume: "</span> << ps->volume << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">"Price: $"</span> << ps->price << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p>创建动态结构时，不能将成员运算符<code>.</code>用于结构名，因为这种结构没有名称，只是知道它的地址。<br>C++专门为这种结构提供了一个运算符:<code>-></code>，来访问被指向结构体的成员。</p>
          </div>
<hr>
<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>模板类<strong>vector</strong>是数组的替代品。</p>
<hr>
<h2 id="与C的差异"><a href="#与C的差异" class="headerlink" title="与C的差异"></a>与C的差异</h2><p>输入/输出的风格差异</p>
<p><strong>scanf/printf(C):</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a; <span class="keyword">long</span> b; <span class="keyword">char</span> c; <span class="keyword">float</span> d; <span class="keyword">double</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%i %li %c %f %lf"</span>,&a,&b,&c,&d,&e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%i\n%li\n%c\n%.03f\n%.09lf\n"</span>,a,b,c,d,e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>cin/cout(C++):</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a; <span class="keyword">long</span> b; <span class="keyword">char</span> c; <span class="keyword">float</span> d; <span class="keyword">double</span> e;</span><br><span class="line">    <span class="built_in">cin</span> >> a >> b >> c >> d >>e;</span><br><span class="line">    <span class="built_in">cout</span> << a << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << b << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << c << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> << fixed << d << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> << fixed << e << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><blockquote>
<p>发出一个DOS命令</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * command)</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a>b?a:b;</span><br></pre></td></tr></tbody></table></figure>
<p>等价于<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a>b){</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote>
<p>lambda expression</p>
</blockquote>
<p>从C++11开始支持匿名函数，也成<strong>Lambda 表达式</strong>,具体形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -> return_type { function_body }</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -> <span class="keyword">int</span> { <span class="keyword">return</span> x + y; }</span><br></pre></td></tr></tbody></table></figure>
<div class="note success">
            <p>如果没有参数，圆括号<code>()</code>可以省略。<br>如果函数体只有一条<code>return</code>语句组成，或者返回类型为<code>void</code>，返回类型也可以省略。</p>
          </div>
<p>C++11也支持<strong>闭包(Closures)</strong>,闭包在方括号<code>[ ]</code>中定义。这种机制允许这些变量被读取或者引用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//no variables defined. Attempting to use any external variables in the lambda is an error.</span></span><br><span class="line">[x, &y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&]       <span class="comment">//any external variable is implicitly captured by reference if used</span></span><br><span class="line">[=]       <span class="comment">//any external variable is implicitly captured by value if used</span></span><br><span class="line">[&, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< algorithm ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< iostream ></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">< array ></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> myArr[<span class="number">5</span>] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    <span class="built_in">array</span><<span class="keyword">int</span>, 5> newArr;</span><br><span class="line">    transform(</span><br><span class="line">        begin(myArr), end(myArr), newArr.begin(),</span><br><span class="line">        [](<span class="keyword">int</span> a){ <span class="keyword">return</span> a*<span class="number">2</span>;}</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: newArr){</span><br><span class="line">        <span class="built_in">cout</span> << i << <span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h4><ul>
<li><strong>自动存储</strong><ul>
<li>函数内部定义的常规变量使用的<strong>自动存储空间</strong>，也被称为<strong>自动变量(Automatic Variable)</strong>，意味着它们所在的函数被调用时自动产生，函数结束时自动消亡。</li>
</ul>
</li>
<li><strong>静态存储</strong><ul>
<li>静态存储是<strong>整个程序执行期间</strong>都存在的存储方式。</li>
<li>使用静态变量的两种方式：<ol>
<li>在函数外面定义它</li>
<li>声明变量时使用关键字<code>static</code></li>
</ol>
</li>
</ul>
</li>
<li>动态存储<ul>
<li><code>new</code>和<code>delete</code>运算符提供了一个更灵活的方法管理<strong>内存池</strong>。</li>
<li>在C++中称为<strong>自由存储空间(free store)</strong>或<strong>堆(heap)</strong>。</li>
<li>使用<code>new</code>和<code>delete</code>让程序员对内存有更大的控制权，但是内存管理也更复杂。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Notes/" rel="tag"># Notes</a>
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Advance/" rel="tag"># Advance</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Tech/Github/" rel="prev" title="Git使用教程">
      <i class="fa fa-chevron-left"></i> Git使用教程
    </a></div>
      <div class="post-nav-item">
    <a href="/Tech/NextMarkdown/" rel="next" title="Next主题下Markdown语法">
      Next主题下Markdown语法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译和链接"><span class="nav-number">1.</span> <span class="nav-text">编译和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#include"><span class="nav-number">1.1.</span> <span class="nav-text">include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linker"><span class="nav-number">1.2.</span> <span class="nav-text">Linker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#头文件"><span class="nav-number">2.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合类型"><span class="nav-number">3.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">3.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-风格字符串"><span class="nav-number">3.2.1.</span> <span class="nav-text">C-风格字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String类"><span class="nav-number">3.2.2.</span> <span class="nav-text">String类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">3.3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">3.4.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new"><span class="nav-number">3.4.1.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-number">3.4.2.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new和delete总结"><span class="nav-number">3.4.3.</span> <span class="nav-text">new和delete总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针算数"><span class="nav-number">3.4.4.</span> <span class="nav-text">指针算数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new创建动态结构-类"><span class="nav-number">3.4.5.</span> <span class="nav-text">new创建动态结构(类)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector类"><span class="nav-number">3.5.</span> <span class="nav-text">Vector类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与C的差异"><span class="nav-number">4.</span> <span class="nav-text">与C的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tips"><span class="nav-number">5.</span> <span class="nav-text">Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System"><span class="nav-number">5.1.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元运算符"><span class="nav-number">5.2.</span> <span class="nav-text">三元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数"><span class="nav-number">5.3.</span> <span class="nav-text">匿名函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">6.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动存储、静态存储和动态存储"><span class="nav-number">6.0.1.</span> <span class="nav-text">自动存储、静态存储和动态存储</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">业余蚊子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fanziwenm" title="GitHub → https://github.com/fanziwenm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:120416678@qq.com" title="E-Mail → mailto:120416678@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.artstation.com/van_hugh" title="Artstation → https://www.artstation.com/van_hugh" rel="noopener" target="_blank"><i class="fa fa-fw fa-artstation"></i>Artstation</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">业余蚊子</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'neutral',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
